1、使用fragment避免配置变化导致生命周期运行而使程序混乱：
Activity 中：（如果是直接在某个布局中固定的fragment，就不用做处理）
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        Log.d(TAG, this + ": onCreate()");


        TextView tv = new TextView(this);
        tv.setText("Hello world");
        setContentView(tv);

        if (getFragmentManager().findFragmentByTag("test_fragment") == null)
        {
            Log.d(TAG, this + ": Existing fragment not found.");
            FragmentTransaction ft = getFragmentManager().beginTransaction();
            ft.add(new TestFragment(), "test_fragment").commit();
        }
        else
        {
            Log.d(TAG, this + ": Existing fragment found.");
        }
    }
		
		
Fragment中：

  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Retain this fragment across configuration changes.
    setRetainInstance(true);
	｝
	
	  @Override
  public void onAttach(Activity activity) {
    super.onAttach(activity);
    mContext = (TaskCallbacks) activity;
  }
  
    @Override
  public void onDetach() {
    super.onDetach();
    mContext = null;
  }

当配置发生改变时，MainActivity正常走生命周期的重构方法，一旦新的Activity创建成功后会回调Fragmentd的onAttach(Activity)方法，即使在配置改变的情况下，保证Fragment当前持有的是最新的Activity的引用。
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2、
API 14及以上
用Application.onTrimLevel(int level)和TRIM_MEMORY_UI_HIDDEN判断应用是否切换至后台运行。
通过INTENT.ACTION_SCREEN_OFF注册广播接受器监听屏幕熄灭
注册Activity.registerLifeStyleCallback监听应用切换至前台运行

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3、通过这个命令查看手机的服务名称列表
adb shell service list
然后就可以dump需要的service的信息了



而对于特定的service，可以用-h查看具体命令，比如package这个服务：
$ adb shell dumpsys package -h
Package manager dump options:
  [-h] [-f] [--checkin] [cmd] ...
    --checkin: dump for a checkin
    -f: print details of intent filters
    -h: print this help
  cmd may be one of:
    l[ibraries]: list known shared libraries
    f[eatures]: list device features
    k[eysets]: print known keysets
    r[esolvers] [activity|service|receiver|content]: dump intent resolvers
    perm[issions]: dump permissions
    permission [name ...]: dump declaration and use of given permission
    pref[erred]: print preferred package settings
    preferred-xml [--full]: print preferred package settings as xml
    prov[iders]: dump content providers
    p[ackages]: dump installed packages
    s[hared-users]: dump shared user IDs
    m[essages]: print collected runtime messages
    v[erifiers]: print package verifier info
    d[omain-preferred-apps]: print domains preferred apps
    i[ntent-filter-verifiers]|ifv: print intent filter verifier info
    version: print database version info
    write: write current settings now
    installs: details about install sessions
    check-permission <permission> <package> [<user>]: does pkg hold perm?
    dexopt: dump dexopt state
    compiler-stats: dump compiler statistics
    service-permissions: dump permissions required by services
    <package.name>: info about given package


adb 查看进程信息？ adb shell dumpsys activity p

adb 查看某个package的状态信息：adb shell dumpsys activity package <com.android.systemui>


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ContextImpl有三种不同的类型：

SystemContext：系统进程SystemServer的Context
AppContext：应用进程的Context
ActivityContext：Activity的Context，只有ActivityContext跟界面显示相关，需要传入activityToken和有效的DisplayId


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
管道：

管道有匿名管道和命名管道，匿名用于亲缘进程通信，而命名可以任意进程间进行通信。

管道的原理: 
管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。

一、匿名管道：

特点：

1.管道只允许具有血缘关系的进程间通信，如父子进程间的通信。

2.管道只允许单向通信。

3.管道内部保证同步机制，从而保证访问数据的一致性。

4.面向字节流

5.管道随进程，进程在管道在，进程消失管道对应的端口也关闭，两个进程都消失管道也消失。


局限性：

① 数据自己读不能自己写。

② 数据一旦被读走，便不在管道中存在，不可反复读取。

③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。

④ 只能在有公共祖先的进程间使用管道。

常见的通信方式有：

单工通信、半双工通信、全双工通信。

二、

三、





--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
先说一下SystemServer这个类：
它主要的工作就是：启动各个Service。
1、由于各Service间有依赖关系，所以有前后顺序。
2、Service的启动是其初始化，后面会有对systemReady的调用，是Service启动完毕需要的一系列操作，以及达到此service启动完毕时要完成的事情（比如AMS中要发送系统启动完成的广播？要启动SystemUI、启动Launcher？）。



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Window 与 View


0、需要重点理解的几个属性
1）、mWindowSession它是通过WindowManagerGlobal.getWindowSession获得的一个Binder服务代理（通过WMS的代理在服务端open一个Session，并在APP端获取该Session的代理），是App端向WMS发送消息的通道。
相对的，mWindow是一个W extends IWindow.Stub Binder服务对象，其实可以看做是App端的窗口对象，主要作用是传递给WMS，并作为WMS向APP端发送消息的通道，在Android系统中存在大量的这种互为C\S的场景。

2）、WindowToken理解成是一个显示令牌（重点是里面的IBinder类型的token属性），无论是系统窗口还是应用窗口，添加新的窗口的时候必须使用这个令牌向WMS表明自己的身份。添加窗口的时候会创建WindowToken，销毁窗口的时候移除WindowToken(removeWindowToken方法)。WindowToken将同一个应用组件(Activity,InputMethod,Wallpaper,Dream)及其内部的窗口组织在一起，换句话说，每一个应用组件的窗口都会对应一个WindowToken，并且这个窗口中的所有子窗口将会对应同一个WindowToken。WindowToken和WindowState是１对多的关系。
token是一个IBinder对象，IBinder在实体端与代理端会相互转换，这里只看实体端，它的取值只有两种:ViewRootImpl中ViewRootImpl.W，或者是ActivityRecord中的IApplicationToken.Stub对象。

3）、WindowState 这个类中比较重要的两个属性：
mSession：指向一个类型为Session的Binder本地对象，使用参数s来初始化，表示当前所创建的WindowState对象是属于哪一个应用程序进程的,Session是进程唯一的。就是用于IPC的windowSession的Binder实体。
mClient：指向一个实现了IWindow接口的Binder代理对象，它引用了运行在应用程序进程这一侧的一个类型为W的Binder本地对象，使用参数c来初始化，通过它可以与运行在应用程序进程这一侧的Activity组件进行通信。就是Client端的mWindow（那个W类）。

4）、WindowManager.LayoutParams有两个很重要的参数type与token。type用来描述窗口的类型，而token其实是标志窗口的分组。

在SurfaceFlinger服务中，每一个SharedBufferStack都对应一个Surface，即一个窗口。


1、WMS的窗口分组有时候会对开发带来影响，如果不知道窗口分组管理，可能有点迷惑，比如Dialog必须使用Activity的Context，PopupWindow不能作为父窗口，尤其要避免作为Webview的容器等，这些都跟WMS窗口的组织有关系。
Android中的窗口主要分为三种：系统窗口、应用窗口、子窗口，Toast就属于系统窗口，而Dialog、Activity属于应用窗口，不过Dialog必须依附Activity才能存在。PopupWindow算是子窗口，必须依附到其他窗口，依附的窗口可以使应用窗口也可以是系统窗口，但是不能是子窗口。
在三种 Window 中，应用 Window 层级范围是 1~99，子 Window 层级范围是 1000~1999，系统 Window 层级范围是 2000~2999。比如StatusBar是系统窗口，对应层级是FIRST_SYSTEM_WINDOW（=2000），Navigationbar也是系统窗口，对应层级是FIRST_SYSTEM_WINDOW+19。
对于应用程序而言，我们理论上是无法创建系统Window，因为没有权限，这个权限只有系统进程有。
（1）、插曲：
WMS使用Choreographer负责所有的窗口动画和屏幕旋转动画，墙纸动画的渲染，用法跟Handler有点类似，他们都是在后期某个时机传入Runable对象，但是他们的回调时机不一样，Handler的处理时机取决与消息队列的处理情况，各个Message的时间都可能不同，而Choreograpoher的回调时机是下一次的VSYNC(垂直刷新同步)，如果在当前时机没有处理完成就会造成失帧，造成造成失帧的原因往往是因为我们布局写的太过复杂，导致16ms内没有完成。 
在KeyguardBouncer中调用mShowRunnable 和 mResetRunnable就用到了Choreographer。

2、WindowManagerService是负责Android的窗口管理，但是它其实只负责管理，比如窗口的添加、移除、大小调整、顺序调整、分组等等（当然，WMS的作用不仅只是管理窗口，它还负责窗口动画、Touch事件等。）。WMS更像在更高的层面对于Android窗口的一个抽象，真正完成图像绘制的是APP端，而完成图层合成的是SurfaceFlinger服务。
单单从窗口显示来看，WMS的作用确实很明确，就是在服务端登记当前存活窗口，后面还会看到，这会影响SurfaceFlinger的图层混合，可以说是为SurfaceFlinger服务的。

3、View必须被添加到窗口中，才会被绘制，或者可以这样理解，只有申请了依附窗口，View才会有可以绘制的目标内存。当APP通过WindowManagerService的代理向其添加窗口的时候，WindowManagerService除了自己进行登记整理，还需要向SurfaceFlinger服务申请一块Surface画布，其实主要是画布背后所对应的一块内存，只有这一块内存申请成功之后，APP端才有绘图的目标（每个view都有自己的onDraw()方法），并且这块内存是APP端同SurfaceFlinger服务端共享的，这就省去了绘图资源的拷贝。
具体过程可以理解为：
每个Activity可以看做是一个图层，其对应一块绘图表面其实就是Surface，Surface绘图表面对应的内存其实是由SurfaceFlinger申请的，并且，内存是APP与SurfaceFlinger间进程共享的。实现机制是基于Linux的共享内存，其实就是MAP+tmpfs文件系统，你可以理解成SF为APP申请一块内存（通过WMS），然后通过binder将这块内存相关的信息传递APP端，APP端往这块内存中绘制内容，绘制完毕，通知SF图层混排，之后，SF再将数据渲染到屏幕。

4、其实整个Android窗口管理简化的话可以分为以下三部分

WindowManagerService：WMS控制着Surface画布的添加与次序，动画还有触摸事件
SurfaceFlinger：SF负责图层的混合，并且将结果传输给硬件显示
APP端：每个APP负责相应图层的绘制，
APP与SurfaceFlinger通信：APP与SF图层之间数据的共享是通过匿名内存来实现的。

作者：看书的小蜗牛
链接：https://juejin.im/post/599cee016fb9a02484491e3e
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

5、关于添加window
1）、我们调用的windowManager.addView其实是调用的WindowManagerGlobal（通过windowManagerImpl调用）的addView方法。而这里面最重要的角色就是ViewRootImpl（这还在app端，因为还没有进行IPC调用）。每次调用windowManager的addView都会创建一个ViewRootImpl。
addView中会调用root.setView()，进一步调用mWindowSession.addToDisplay()，这里IPC调用到com.android.server.wm.Session.addToDisplay()——>WMS.addWindow()。而addWindow()中又会创建对应的WindowState，并通过WindowState.attach()创建SurfaceSession。

2）、ViewRootImpl相当于是MVC模型中的Controller，它有以下职责：1. 负责为应用程序窗口视图创建Surface。 2. 配合WindowManagerService来管理系统的应用程序窗口。 3. 负责管理、布局和渲染应用程序窗口视图的UI。

3）、窗口的插入还是比较复杂的，总结而言:
1.非应用窗口依据mBaseLayer插入，越高越靠前，墙纸和输入法会有特殊处理，在下面还会进行调整。
2.应用窗口参考activity的位置插入，通常应该被插入在其activity所在task的顶部或者该activity上面的activity的最后一个窗口的下面
3.子窗口依据mSubLayer插入
最终插入的地方有两个：DisplayContent所持有的记录该屏幕下所有窗口顺序的WindowList，以及新窗口的WindowToken所记录的所有属于它的WindowState中的WindowList列表。

这是androidN之前的方式了，从androidO开始有了改变，好像的直接通过WindowToken来分析window的层级了。所以addWindow中创建WindowToken用的构造方法参数变多了，而且调用了win.mToken.addWindow(win);利用了WindowToken类中的属性WindowList。

6、关于stack：
Stack对应WindwoManagerService中的TaskStack类，如果是在ActivityManagerService就对应ActivityStack类，为什么要引入TaskStack和ActivityStack类呢？因为他们的作用是管理TASK,一个Stack中包含了多个Task。应用程序也可以在AndroidManifest.xml文件中通过android:launchMode指定当前Activity运行在哪一个Task中。

默认的几个Stack:
Id等于0：Home Stack，就是Launcher所在的Stack。但是还有一些系统界面也运行在这个Stack上，比如近期任务的界面。
Id等于1：FullScreen Stack，全屏的Activity所在的Stack。但其实在分屏模式下，Id为1的Stack只占了半个屏幕。
Id等于2：Freeform模式的Activity所在Stack
Id等于3：Docked Stack　在分屏模式下，屏幕有一半运行了一个固定的应用，这就是Docked Stack
Id等于4：Pinned Stack 这是画中画Activity所在的Stack



18、窗口Z轴的位置
WindowState中一个属性为mLayer，表示窗口在Ｚ轴的位置，mLayer值越小，窗口越靠后，mLayer值越大，窗口越靠前，最前面的一个窗口就作为焦点窗口，可以接收触摸事件。mLayer的值不是固定不变的。mLayer是通过WindowState的另一个成员变量mBaseLayer的值计算得到，mBaseLayer的值是固定不变的，只和窗口类型有关。
窗口的Z轴位置除了跟mBaseLayer有关与之外，还跟窗口在堆栈中的位置有关。

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PowerManagerService
一、WakeLock
1、分类：
WakeLock分为app层、PMS层、native层，这三者分别用不同的锁类型进行表述，且之间有对应关系。
app层虽然都叫WakeLock，但实际对应的flag很多，比如PowerManager.PARTIAL_WAKE_LOCK。
PMS层都是WakeLock这一种(名字与app层相同)。
native层是SuspendBlocker（在PMS中其实只用了对应的两个实例对象：mWakeLockSuspendBlocker锁  和  mDisplaySuspendBlocker锁）

当申请了PARTIAL_WAKE_LOCK类型的WakeLock锁、DRAW_WAKE_LOCK类型的WakeLock锁(前提是处于Doze模式)、屏幕处于唤醒、屏保时，都会持有一个mWakeLockSuspendBlocker锁，会在/sys/power/wake_lock 节点中写入”PowerManager.WakeLocks“，从而保持设备处于唤醒状态。

还有一种比较特殊的锁：
PowerManagerService.Broadcasts锁
这个类型的SuspendBlocker并没有在PMS中进行实例化，它以构造方法的形式传入了Notifier中，Notifier类相当于是PMS的”中介“，PMS中和其他服务的部分交互通过Notifier进行，还有比如亮屏广播、灭屏广播等，都是由PMS交给Notifier来发送，这点在下篇文章中进行分析。因此，如果CPU在广播发送过程中进入休眠，则广播无法发送完成，因此，需要一个锁来保证Notifier中广播的成功发送，这就是PowerManagerService.Broadcasts 锁的作用，当广播发送完毕后，该锁立即就释放了。

2、app层WaleLock的级别：
//如果持有该类型的wakelock锁，则按Power键灭屏后，即使允许屏幕、按键灯灭，也不会释放该锁，CPU不会进入休眠状态
public static final int PARTIAL_WAKE_LOCK;
//Deprecated，如果持有该类型的wakelock锁，则使屏幕保持亮/Dim的状态，键盘灯允许灭，按Power键灭屏后，会立即释放
public static final int SCREEN_DIM_WAKE_LOCK;
//Deprecated，如果持有该类型的wakelock锁，则使屏幕保持亮的状态，键盘灯允许灭，按Power键灭屏后，会立即释放
public static final int SCREEN_BRIGHT_WAKE_LOCK
//Deprecated，如果持有该类型的wakelock锁，则使屏幕、键盘灯都保持亮，按Power键灭屏后，会立即释放
public static final int FULL_WAKE_LOCK
//如果持有该锁，则当PSensor检测到有物体靠近时关闭屏幕，远离时又亮屏，该类型锁不会阻止系统进入睡眠状态，比如
//当到达休眠时间后会进入睡眠状态，但是如果当前屏幕由该wakelock关闭，则不会进入睡眠状态。
public static final int PROXIMITY_SCREEN_OFF_WAKE_LOCK
//如果持有该锁，则会使屏幕处于DOZE状态，同时允许CPU挂起，该锁用于DreamManager实现Doze模式，如SystemUI的DozeService
public static final int DOZE_WAKE_LOCK
//如果持有该锁,则会时设备保持唤醒状态，以进行绘制屏幕，该锁常用于WindowManager中，允许应用在系统处于Doze状态下时进行绘制
public static final int DRAW_WAKE_LOCK


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Activity:
1、一开始从ActivityThread中的handleLaunchActivity方法开始分析，首先加载Activity的字节码文件，利用反射的方式创建一个Activity对象，调用Activity对象的attach方法，在attach方法中，创建系统需要的Window并为设置回调，这个回调定义在Window之中，由Activity实现，当Window的状态发生变化的时候，就会回调Activity实现的这些回调方法。调用attach方法之后，Window被创建完成，这时候需要关联我们的视图，在handleLaunchActivity中的attach执行之后就要执行handleLaunchActivity中的callActivityOnCreate，在onCreate中我们会调用setContentView方法。通过setContentView，创建了Activity的顶级View---DecorView，DecorView的内容栏（mContentParent）用来显示我们的布局，这只是添加的过程，还要有一个显示的过程，显示的过程就要调用ActivityThead中handleLaunchActivity中的handleResumeActivity方法了，最后会调用makeVisible方法，把这个DecorView显示出来。
这是之前的流程，现在生命周期有特定的类管理了。

2、什么是Activity的切换呢？　 
前一个Activity从resume状态变成pause状态，后一个Activity进入到resume状态，将前一个resume状态的窗口设置成不可见，后一个窗口设置成可见。

切换的步骤:
ActivityStack类的成员函数startActivityLocked首先会给正在启动的Activity组件准备一个切换操作，这里所说的切换操作，你可以理解成前面设置的动画类型。
接着再调用其它的成员函数来通知前一个激活的Activity组件进入到Paused状态。
等到前一个激活的Activity组件进入到Paused状态之后，ActivityManagerService服务就会检查用来运行正在启动的Activity组件的进程启动起来了没有。如果这个进程还没有启动，那么ActivityManagerService服务就会将该进程启动起来，然后再调用ActivityStack类的成员函数realStartActivityLocked来将正在启动的Activity组件加载起来，并且将它的状态设置为Resumed。这里面具体又分成两个小点，一是setAppVisibility 、二是通知lauch Activity。
最后通知WindowManagerService服务执行前面所准备的切换操作（这里就包括了对应的动画的执行）。



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

JNI
1、JNIEnv*  这是一个与线程相关的变量。是用来操作Java层的。

它就是提供了一些JNI系统函数。通过这些函数，可以 调用java函数   和  操作jobject对象  等等。



--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
C++

一、
1、内联函数
类的成员函数可以在类内实现也可以只在类内部声明，在类外部实现。
他们主要的区别在于，
类内实现的成员函数有可能被编译器优化为内联函数，
而类外的就得加关键字inline。
这里要注意的是，及时加入了inline或者是在类内实现的成员函数，
也不一定能够成为内联函数，如果编译器觉得函数太复杂就不内联了。

一般的比较短小的函数写在类内做内联还是比较好的。
写在类外有利于隐藏实现的细节，达到保护的作用。
一般的类库只提供头文件，即类的定义，而类的实现就不告诉你了，
编译成.dll给你，你就不知道它是怎么实现的了，达到商业保密的作用。

2、当对象生存周期结束时对象被自动撤销, 所占用的内存被回收, 需要注意的是, 如果对象的成员函数中有使用 new 或者 malloc 申请的动态内存程序不会对其进行释放, 需要我们手动进行清理, 否则会造成内存泄露。

3、C++中可以同时using 两个命名空间，但前提是这两个空间中没有相同的变量或函数，否则会提示 "ambiguous symbol"的错误信息。
 eg:
 using namespace std;
 using namespace <自己的命名空间>;
 
 4、
 C++ #include " " 与 <>有什么区别
简言之 #include <> 和 #include "" 都会在实现定义的位置查找文件，并将其包含。区别是若 #include "" 查找成功，则遮蔽 #include <> 所能找到的同名文件；否则再按照 #include <> 的方式查找文件。另外标准库头文件都放在 #include <> 所查找的位置。一般来说 #include <> 的查找位置是标准库头文件所在目录， #include "" 的查找位置是当前源文件所在目录。不过这些都可由编译器调用参数等配置更改。

5、#include的作用是把它后面所写的那个文件的内容，完完整整地、 一字不改地包含到当前的文件中来。值得一提的是，它本身是没有其它任何作用与副功能的，它的作用就是把每一个它出现的地方，替换成它后面所写的那个文件的 内容。简单的文本替换，别无其他。
.h头文件中，只能存在变量或者函数的声明， 而不要放定义。

6、使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。

引用总结
　　（1）在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。

　　（2）用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。

　　（3）引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。

　　（4）使用引用的时机。流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。

7、



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
几个要复习的地方：
1、intentfilter 规则
action、category、data（mimetype、URI（scheme、host、。。。））

2、 touchEvent分发
要总结的几点：
1）、以前都理解错了，onTouchEvent返回true并不代表此事件被拦截了，所以后续事件还是会调用onInterceptTouchEvent方法。而，如果某viewgroup 在此事件调用onInterceptTouchEvent时返回了true，则后续的事件才不会再调用此viewgroup的onInterceptTouchEvent并且后续事件会分配给该viewgroup的onTouchEvent处理。一个事件序列只能被一个viewgroup拦截。
2）、若某view（或者某viewgroup的所有子view都）的onTouchEvent返回了false，那么此view的父容器（或者此viewgroup）的onTouchEvent会被调用。以此类推，直到activity。
3）、若某view的onTouchEvent返回false，那么后续事件都不会再交给它处理了。


3、系统启动流程


4、Binder

1）、面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体（本地对象）位于一个进程中，而它的引用（代理对象）却遍布于系统的各个进程之中。最诱人的是，这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。

2）、IBinder/IInterface/Binder/BinderProxy/Stub
我们使用AIDL接口的时候，经常会接触到这些类，那么这每个类代表的是什么呢？

IBinder是一个接口，它代表了一种跨进程传输的能力；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。

IBinder负责数据传输，那么client与server端的调用契约（这里不用接口避免混淆）呢？
这里的IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。

Java层的Binder类，代表的其实就是Binder本地对象。
BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。

在使用AIDL的时候，编译工具会给我们生成一个Stub的静态内部类；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。

3）一次完整的调用远程过程：
BinderProxy对象mRemote首先用Parcel把数据序列化了，然后调用了transact方法；这个transact到底做了什么呢？这个Proxy类在asInterface方法里面被创建，前面提到过，如果是Binder代理那么说明驱动返回的IBinder实际是BinderProxy, 因此我们的Proxy类里面的mRemote实际类型应该是BinderProxy；我们看看BinderProxy的transact方法：(Binder.java的内部类)

public native boolean transact(int code, Parcel data, Parcel reply,
            int flags) throws RemoteException;
这是一个本地方法；它的实现在native层，具体来说在frameworks/base/core/jni/android_util_Binder.cpp文件，里面进行了一系列的函数调用，调用链实在太长这里就不给出了；要知道的是它最终调用到了talkWithDriver函数；看这个函数的名字就知道，通信过程要交给驱动完成了；这个函数最后通过ioctl系统调用，Client进程陷入内核态，Client调用add方法的线程挂起等待返回；驱动完成一系列的操作之后唤醒Server进程，调用了Server进程本地对象的onTransact函数（实际上由Server端线程池完成）。
在Server进程里面，onTransact根据调用号（每个AIDL函数都有一个编号，在跨进程的时候，不会传递函数，而是传递编号指明调用哪个函数）调用相关函数；在这个例子里面，调用了Binder本地对象的add方法；这个方法将结果返回给驱动，驱动唤醒挂起的Client进程里面的线程并将结果返回。于是一次跨进程调用就完成了。
（来源链接：http://weishu.me/2016/01/12/binder-index-for-newer/）

4）、对比：
从通信方式考虑：
目前linux支持的IPC包括传统的管道，System V IPC，即消息队列/共享内存/信号量，以及socket中只有socket支持Client-Server的通信方式。当然也可以在这些底层机制上架设一套协议来实现Client-Server通信，但这样增加了系统的复杂性，在手机这种条件复杂，资源稀缺的环境下可靠性也难以保证。


从传输性能考虑：
socket作为一款通用接口，虽然支持Client-Server的通信方式，但其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。
消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。
共享内存虽然无需拷贝，但控制复杂，难以使用。

从安全性考虑：
Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。首先传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。


基于以上原因，Android需要建立一套新的IPC机制来满足系统对通信方式，传输性能和安全性的要求，这就是Binder。Binder基于Client-Server通信模式，传输过程只需一次拷贝，为发送发添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。

5）、
Binder驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。驱动和应用程序之间定义了一套接口协议，主要功能由ioctl()接口实现，不提供read()，write()接口，因为ioctl()灵活方便，且能够一次调用实现先写后读以满足同步交互，而不必分别调用write()和read()。Binder驱动的代码位于linux目录的drivers/misc/binder.c中。

为了实现用户空间到用户空间的拷贝，mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的‘秘密’。

client端传递到binder驱动的数据在内核空间，server端不能直接访问的，具体是怎么执行的？？？？？？？？？具体如下：
 t->buffer->data所指向的地址是内核空间的，现在要把数据返回给Service Manager进程的用户空间，而Service Manager进程的用户空间是不能访问内核空间的数据的，所以这里要作一下处理。怎么处理呢？我们在学面向对象语言的时候，对象的拷贝有深拷贝和浅拷贝之分，深拷贝是把另外分配一块新内存，然后把原始对象的内容搬过去，浅拷贝是并没有为新对象分配一块新空间，而只是分配一个引用，而个引用指向原始对象。Binder机制用的是类似浅拷贝的方法，通过在用户空间分配一个虚拟地址，然后让这个用户空间虚拟地址与 t->buffer->data这个内核空间虚拟地址指向同一个物理地址，这样就可以实现浅拷贝了。怎么样用户空间和内核空间的虚拟地址同时指向同一个物理地址呢？请参考前面一篇文章浅谈Service Manager成为Android进程间通信（IPC）机制Binder守护进程之路，那里有详细描述。这里只要将t->buffer->data加上一个偏移值proc->user_buffer_offset就可以得到t->buffer->data对应的用户空间虚拟地址了。调整了tr.data.ptr.buffer的值之后，不要忘记也要一起调整tr.data.ptr.offsets的值。
————————————————
版权声明：本文为CSDN博主「罗升阳」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/luoshengyang/article/details/6629298


6）、
我们知道Java层面其实都是对Native层面的包装。

既然Binder驱动中都会记录Binder实体与Binder引用对象，在C++层面是直接保持的BBinder作为实体类，在Java层面呢？
Java层面的Server端都会有个Service继承自某个Stub，而这个Stub又继承自Binder类。所以，实例化此Java层面的Service类时，就会调用Binder类的构造函数，最终生成一个JavaBBinderHolder对象，这个对象里面包含有一个JavaBBinder类型的Binder实体。
我们就是要把JavaBBinderHolder里面的JavaBBinder类型Binder实体添加到C++层面的Service Manager中去，以便使得这个HelloService有Client来请求服务时，由Binder驱动程序来唤醒这个Server线程，进而调用这个JavaBBinder类型Binder实体的onTransact函数来进一步处理
————————————————
版权声明：本文为CSDN博主「罗升阳」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/luoshengyang/article/details/6642463


7)、对于Binder内存只拷贝一次的理解：
某个用户空间的进程A要与用户空间的进程B进行IPC，即B是目标进程。
则：因为拷贝数据的时候，A进程要先申请内存，而这个动作是在target_proc即目标进程的内存空间中申请的内存，故是直接将数据拷贝到目标进程的内存空间中的。由于mmap的存在，也相当于直接拷贝到了内核空间中。而，目标进程的内存地址与内核空间的内存地址有一个固定的offset，所以，内核可以直接告诉目标进程到B进程自己的虚拟内存地址的哪个地址去取数据。
Client端传递数据给Server端时，是写入数据到Server端对应的内核空间；而Server端返回处理结果时，是写入数据到Client端对应的内核空间的。


8）、对于通过bindService启动的Service，如果要深究Activity的bindService流程，可以按以下几步来分析

1、Activity调用bindService：通过Binder通知ActivityManagerService，要启动哪个Service
2、ActivityManagerService创建ServiceRecord，并利用ApplicationThreadProxy回调，通知APP新建并启动Service启动起来
3、ActivityManagerService把Service启动起来后，继续通过ApplicationThreadProxy，通知APP，bindService，其实就是让Service返回一个Binder对象给ActivityManagerService，以便AMS传递给Client
4、ActivityManagerService把从Service处得到这个Binder对象传给Activity，这里是通过IServiceConnection binder实现。
5、Activity被唤醒后通过Binder Stub的asInterface函数将Binder转换为代理Proxy，完成业务代理的转换，之后就能利用Proxy进行通信了。

作者：看书的小蜗牛
链接：https://juejin.im/post/58c920ba61ff4b0060120855
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



5、handler消息循环机制
一个线程只能有一个looper用来轮询唯一的一个消息队列，即线程，looper，消息的队列的关系是一一对应的。而handler和looper之间是多对一的关系，即一个looper可以由多个handler来为它服务。在handler的构造函数中，主要工作就是把handler和它要服务的looper，消息队列关联起来。

handler可以向队列中发送消息或者添加一个可执行的runnable对象，消息队列会安排在某一时刻进行消息处理或者执行runnable对象run方法：

post(Runnable r)：将runnable对象加入消息队列，该runnable对象将会被消息队列所在线程执行。
postAtTime(Runnable, long)： 将runnable对象加入消息队列，在指定的时间执行该runnable对象。
postDelayed(Runnable r, long delayMillis)：将runnable对象加入消息队列，经过指定延迟时间后执行。
sendEmptyMessage(int what)：将一条仅包含what值的消息发送给消息队列
sendMessage(Message msg)：将一条消息加入消息队列
sendMessageAtTime(Message msg, long uptimeMillis)：在指定时间将一条消息加入队列尾部
sendMessageDelayed(Message msg, long delayMillis)： 在经过指定时间延迟后，将一条消息加入队列尾部
        
通过这些方法，handler将message对象交给了消息队列messageQueue。looper从消息队列中取出message后，会调用message所持有的handlerdispatch方法，分发给handler来处理该消息



学习：
1 ClassLoader

    public static ClassLoader getPkgClassLoader(Context pkgContext) {
        final String dexPath = pkgContext.getApplicationInfo().sourceDir;
        final String libraryPath = null;
        final ClassLoader parentLoader = pkgContext.getClassLoader();
        
        // TODO Create PathClassLoader in a Privileged block ?? --- undetermined
        ClassLoader clsLoader = new PathClassLoader(dexPath, libraryPath, parentLoader); // NOSONAR
        return clsLoader;
    }




---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


根据alps\build\core\main.mk，这应该是android编译系统的主target：
# This is the default target.  It must be the first declared target.
.PHONY: droid
DEFAULT_GOAL := droid
$(DEFAULT_GOAL): droid_targets



Makefile：
1、Makefile的基本规则：

    target ... : prerequisites ...(在同一行，或者用/分隔为多行)
            command(定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头)
            ...
            ...

    target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。

    prerequisites就是，要生成那个target所需要的文件或是目标。

    command也就是make需要执行的命令。（一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。）

这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新或者target不存在的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。

edit : main.o kbd.o command.o display.o /
           insert.o search.o files.o utils.o
            cc -o edit main.o kbd.o command.o display.o /
                       insert.o search.o files.o utils.o

    main.o : main.c defs.h
            cc -c main.c
    kbd.o : kbd.c defs.h command.h
            cc -c kbd.c
    command.o : command.c defs.h command.h
            cc -c command.c
    display.o : display.c defs.h buffer.h
            cc -c display.c
    insert.o : insert.c defs.h buffer.h
            cc -c insert.c
    search.o : search.c defs.h buffer.h
            cc -c search.c
    files.o : files.c defs.h buffer.h command.h
            cc -c files.c
    utils.o : utils.c defs.h
            cc -c utils.c
    clean :
            rm edit main.o kbd.o command.o display.o /
               insert.o search.o files.o utils.o




clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字（make clean）。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。


2、
	include的语法是：

    include <filename>

    filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符），多个文件之间可以用空格隔开。

	你可以在include前加一个减号“-”。如：

    -include <filename>
    其表示，无论include过程中出现什么错误，都不要报错继续执行。
	
3、
make工作时的执行步骤入下：（想来其它的make也是类似）

    1、读入所有的Makefile。
    2、读入被include的其它Makefile。
    3、初始化文件中的变量。
    4、推导隐晦规则，并分析所有规则。
    5、为所有的目标文件创建依赖关系链。
    6、根据依赖关系，决定哪些目标要重新生成。
    7、执行生成命令。

4、objects = *.o

    上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：

    objects := $(wildcard *.o)

这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。


5、
为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。

    .PHONY : clean

只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：

     .PHONY: clean
    clean:
            rm *.o temp

我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。由于伪目标的特性是，总是被执行的，不管它的依赖是否比它新。

6、
make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：

    @echo 正在编译XXX模块......

当make执行时，会输出“正在编译XXX模块......”字串，但不会输出命令，如果没有“@”，那么，make将输出：

    echo 正在编译XXX模块......
    正在编译XXX模块......

如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令，这两条命令应该在同一行。

7、
如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。

有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。

为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：

   clean:
            -rm -f *.o

还有一个全局的办法是，给make加上“-i”或是“--ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。

还有一个要提一下的make的参数的是“-k”或是“--keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。


8、
定义变量
变量会在使用它的地方精确地展开，就像C/C++中的宏一样。替换。
有两种定义方式，第一种部分前后，第二种只能用之前定义的变量。

先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：

    foo = $(bar)
    bar = $(ugh)
    ugh = Huh?

    all:
            echo $(foo)

我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。

这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：

    CFLAGS = $(include_dirs) -O
    include_dirs = -Ifoo -Ibar

当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：

    CFLAGS = $(CFLAGS) -O

    或：

    A = $(B)
    B = $(A)

这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。

为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：

    x := foo
    y := $(x) bar
    x := later

其等价于：

    y := foo bar
    x := later

值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：

    y := $(x) bar
    x := foo

那么，y的值是“bar”，而不是“foo bar”。

9、
（1）、
FOO ?= bar

其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：

    ifeq ($(origin FOO), undefined)
      FOO = bar
    endif
	
（2）、
替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。

还是看一个示例吧：

    foo := a.o b.o c.o
    bar := $(foo:.o=.c)


（3）、
“把变量的值再当成变量”。先看一个例子：

    x = y
    y = z
    a := $($(x))

在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）

比如(subst是个函数):
    x = variable1
    variable2 := Hello
    y = $(subst 1,2,$(x))
    z = y
    a := $($($(z)))

这个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值——“Hello”。（喔，好不容易）


（4）、
我们可以使用“+=”操作符给变量追加值，如：

    objects = main.o foo.o bar.o utils.o
    objects += another.o

于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”

（5）、
如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：

    override <variable> = <value>

    override <variable> := <value>

当然，你还可以追加：

    override <variable> += <more text>
（6）、
使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。


10、
函数的调用（make带的函数并不是很多）：
函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：

    $(<function> <arguments>)

或是

    ${<function> <arguments>}

这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。

函数分类：字符串处理函数、文件名操作函数、

还有
 （1）、foreach函数：

  $(foreach <var>,<list>,<text>)

这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式


 （2）、if函数：
  $(if <condition>,<then-part>)
或是

    $(if <condition>,<then-part>,<else-part>)
可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part>会被计算。

 （3）、call函数：
$(call <expression>,<parm1>,<parm2>,<parm3>...)

<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而表达式<expression>的返回值就做为call函数的返回值。
比如：
    reverse =  $(2) $(1)
    foo = $(call reverse,a,b)

此时的foo的值就是“b a”。


 （4）、
 shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：

    contents := $(shell cat foo)

    files := $(shell echo *.c)

注意，这个函数会新生成一个Shell程序来执行命令
 
 （5）、还有：
 $(warning <text ...>)
 
 $(error <text ...>)
  产生一个致命的错误，<text ...>是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：

    示例一：

    ifdef ERROR_001

    $(error error is $(ERROR_001))

    endif



    示例二：

    ERR = $(error found an error!)

    .PHONY: err

    err: ; $(ERR)


    示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。




11、大致的理解是：

在Makefile中遇到$就会把后面跟的变量名展开。

但如果是$$其实作用是引用shell脚本中定义的变量。这个要在shell定义此变量的同一行使用。。。

而，要在shell脚本中使用Makefile定义的变量（不是指在shell命令后面直接带的参数），应该在同一行中先重新定义这些变量为shell变量在调用shell脚本。因为shell在Makefile中每行都是用单独的进程处理的。

在makefile的规则命令行中使用$var就是在命令中引用makefile的变量，这里仅仅是读取makefile的变量然后扩展开（makefile文件中所有的单$跟变量名都会被扩展），将其值作为参数传给了一个shell命令；而$$var是在访问一个shell命令内定义的变量，而非makefile的变量。如果某规则有n个shell命令行构成，而相互之间没有用';'和'\'连接起来的话，就是相互之间没有关联的shell命令，相互之间也不能变量共享。 









---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Binder:

一、Java 层 与 Native 层的 Binder 及服务调用：
1、

Java层调用ServiceManger.addService后，最终是向Native层的ServiceManager请求增加服务的。
Native层的ServiceManager是只有一个的，而java层的ServiceManager相对于Native的ServiceManager也只是个proxy端，这样，不管是通过Native add service还是通过java add service，整个Android都可以拿到这个service的Binder。
详见：https://blog.csdn.net/fchyang/article/details/82260138

具体添加某service到ServiceManager的逻辑是：
Server创建了Binder实体，为其取一个字符形式可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给SMgr，通知SMgr注册一个名叫张三的Binder，它位于某个Server中。驱动为这个穿过进程边界的Binder创建位于内核中的实体节点以及SMgr对实体的引用，将名字及新建的引用打包传递给SMgr。SMgr收数据包后，从中取出名字和引用填入一张查找表中。

另外注意：
java层的binder实体其实要深入到native层：
Binder.java中的Binder只是对native层BBinder的一个简单封装,真正的实例化还是通过JNI到native层去创建一个JavaBBinderHolder对象，并初始化gBinderOffsets，让其能映射Java层Binder对象，而JavaBBinderHolder中又可以实例化BBinder的实例JavaBBinder，不过BBinder的实例化时机并不在这里，而是在Parcel对象writeStrongBinder的时候



2、java层可以直接通过ServiceManager调用在Native层中注册的Service。

3、Binder中 Server 端的实现是线程池的方式，而不是单线程队列的方式，这样一来，单线程队列的话，Server 的代码是线程安全的，线程池的话，Server 的代码则不是线程安全的，需要开发者自己做好多线程同步。

4、原来打开binder设备的地方是和进程相关的啊，一个进程打开一个就可以了。而binder驱动也会为这个进程维护一个binder_proc数据结构。

5、各结构体理解：
1）、binder_proc是描述进程上下文信息的，每一个用户空间的进程都对应一个binder_proc结构体。Binder驱动的文件节点是"/dev/binder"，每当一个程序打开该文件节点时；Binder驱动中都会新建一个binder_proc对象来保存该进程的上下文信息。
binder_proc中共有4棵红黑树！！！！！！！！！！！！！！！！！！

2）、关于binder_proc结构体中的两个红黑树（它们都是表示同一样东西，只不过是为了内部查找方便而用两个红黑树来表示）：
refs_by_desc;（client端或者ServiceManager进程使用---lyc---）
refs_by_node;（binder驱动使用---lyc---）
当前进程中的binder_ref红黑树节点都不是本进程自己创建的，要么是Service进程将binder_ref插入到ServiceManager中去，要么是ServiceManager进程将binder_ref插入到Client中去。
比如在Client端getService的时候，binder驱动会在Client进程中通过binder_get_ref_for_node为Client创建binder_ref结构体，并分配句柄，同时插入到refs_by_desc红黑树中，可见refs_by_node红黑树，主要是给binder驱动往用户空间写数据使用的。
相对的refs_by_desc主要是为了用户空间往binder驱动写数据使用的，当用户空间已经获得Binder驱动为其创建的binder_ref引用句柄后，就可以通过binder_get_ref从refs_by_desc找到响应binder_ref，进而找到目标binder_node。
user_buffer_offset成员变量是一个ptrdiff_t类型的变量，它表示的是内核使用的虚拟地址与进程使用的虚拟地址之间的差值。

3）、系统服务与bindService等启动的服务的区别：https://juejin.im/post/58c90816a22b9d006413f624#heading-5
主要区别
	（1）、系统服务本身实现binder，它就是个binder。而四大组件之一的Service本身不是binder，通过bindService返回的binder才是。
	（2）、使用方式：使用系统服务一般都是通过ServiceManager的getService得到服务的句柄，这个过程其实就是去ServiceManager中查询注册系统服务。而bindService启动的服务(这种属于四大组件之一，跟系统服务有本质区别)，主要是去ActivityManagerService中去查找相应的Service组件，最终会将Service内部Binder的句柄传给Client。

4）、client端getService之后，便可以获取binder_ref引用（ServiceManager通过驱动在client端对应的binder_proc中创建的），进而获取到Service端的binder_proc与binder_node信息（binder_ref节点中都要这些信息），之后Client便可有目的的将binder_transaction事务插入到binder_proc的待处理列表，并且，如果Service端进程正在睡眠，就唤起进程，其实这里到底是唤起进程还是线程也有讲究，对于Client向Service发送请求的状况，一般都是唤醒binder_proc上睡眠的线程。


6、
IInterface
接口表明了这个类可以通过asBinder()转成一个IBinder，从而在binder驱动中跨进程运输。
例如：在某个client通过binder与某个service通信的时候，可以通过下面的方式把自己的某个binder服务发送个此service，然后此service也就能通过这个binder通知此client了。这里就是通过调用asBinder实现的。（通过asBinder传递出去，接收端通过asInterface再转换成proxy来使用。
注意：Binder驱动过来的IBinder不是Binder，而是BinderProxy，但是为什么我们之前传的参数是一个binder，为什么读出来以后变成了BinderProxy了呢？答案就在这个readStrongBinder里，看jni层的源码可以知道，系统在客户端收到(readStrongBinder)IBinder以后，会保存下来，通过Binder驱动传给Service时，会通过之前保存的Binder在底层创建BinderProxy，然后传给上层）
Parcel data = Parcel.obtain();
data.writeStrongBinder(caller != null ? caller.asBinder() : null);

IBinder
接口表明了类具有跨进程的能力，即可以通过调用transact方法“使用”Binder驱动。
例如：在某个client通过binder与某个service通信的时候，需要调用mRemote.transact()方法来把数据通过Binder驱动传递给Service。 这是通过调用transact()实现的。

6.1、先获取ServiceManager代理Binder对象：
1）、获取的过程分java层和Native层。java层是通过getIServiceManager()，native层是通过defaultServiceManager()。
二者都是进入到Native层的ProcessState类的getContextObject(0)方法去获取的此代理对象，其实就是调用的ProcessState类的getStrongProxyForHandle(0)，实际就是返回一个BpBinder对象。（网上说这个过程不涉及进程间通信。但其实会有一个调用IPCThreadState::transact的过程，去确认ServiceManager是否已经注册到Binder驱动中）
得到这个BpBinder对象后，新建BpServiceManager对象并把BpBinder对象作为属性mRemote。（BpServiceManager就在IServiceManager.cpp中定义，根据继承关系，一层层调用基类构造函数，最终是在BpRefBase的构造函数中设置的MRemote值为此BpBinder）

2）、获取到代理后（实际就是调用BpBinder::transact成员函数。在BpBinder::transact函数中，又会调用IPCThreadState::transact成员函数，这里就是最终与Binder驱动程序交互的地方了。）
	在Android系统的Binder机制中，Server和Client拿到这个Service Manager远程接口之后怎么用呢？
    对Server来说，就是调用IServiceManager::addService这个接口来和Binder驱动程序交互了，即调用BpServiceManager::addService 。而BpServiceManager::addService又会调用通过其基类BpRefBase的成员函数remote获得原先创建的BpBinder实例，接着调用BpBinder::transact成员函数。在BpBinder::transact函数中，又会调用IPCThreadState::transact成员函数，这里就是最终与Binder驱动程序交互的地方了。回忆一下前面的类图，IPCThreadState有一个PorcessState类型的成中变量mProcess，而mProcess有一个成员变量mDriverFD，它是设备文件/dev/binder的打开文件描述符，因此，IPCThreadState就相当于间接在拥有了设备文件/dev/binder的打开文件描述符，于是，便可以与Binder驱动程序交互了。
    对Client来说，就是调用IServiceManager::getService这个接口来和Binder驱动程序交互了。具体过程上述Server使用ServiceManager的方法是一样的，这里就不再累述了。

3）、注意：
杂：
binder_transaction_data这个数据结构就是在IPCThreadState::writeTransactionData中形成的。最终是把cmd 和 binder_transaction_data一起写入到mOut中。
然后会调用：IPCThreadState::waitForResponse()。
client端和Server端最后都是通过talkwithdriver()里面的ioctl()方法最终进入到驱动程序中运行的。对应了Binder驱动程序的binder_ioctl函数。

7、对于addService,即添加系统服务。
会进行权限检查（在service_manager.c中）：
int svc_can_register(unsigned uid, uint16_t *name)
 {
    unsigned n;
    // 谁有权限add_service 0进程（即root用户），或者 AID_SYSTEM进程（即system 进程，1000）
    if ((uid == 0) || (uid == AID_SYSTEM))
        return 1;
     for (n = 0; n < sizeof(allowed) / sizeof(allowed[0]); n++)
        if ((uid == allowed[n].uid) && str16eq(name, allowed[n].name))
            return 1;
    return 0;
}
所以，只有root 、system进程或者特殊配置的进程 才能addService成为系统服务到ServiceManager，其它app中的服务都是继承Service组件，通过AMS进行管理的。

8、对于bindService：
Service的bind需要一个ServiceConnection对象，这个对象其实是为了AMS端在启动Service后回调用的。
Activity的bindService流程：
1）、Client的Activity调用bindService：通过Binder通知ActivityManagerService，要启动哪个Service
2）、ActivityManagerService创建ServiceRecord，并利用ApplicationThreadProxy回调，通知目标APP新建并启动对应的Service。
3）、ActivityManagerService把Service启动起来后，继续通过ApplicationThreadProxy，通知APP进行bindService（即，会执行服务端的Service中的onBind()方法），其实就是让Service返回一个Binder对象给ActivityManagerService，以便AMS传递给Client
4）、ActivityManagerService把从Service处得到这个Binder对象传给Client的Activity，这里是通过IServiceConnection这个binder实现。
5）、Activity被唤醒后通过Binder Stub的asInterface函数将Binder转换为代理Proxy（即onConnected中的操作），完成业务代理的转换，之后就能利用Proxy进行通信了。

9、binder的内存限制：即通过mmap函数映射的内存大小。
1）、binder驱动要求映射的内存大小不能超过4M
2）、ServiceManager默认需要映射的内存大小为128K
3）、一般应用程序可映射的内存大小为1M，也就是说通过binder传输的数据大小不能超过1M，也就是说通过contentprovider或者intent传递的数据大小不能超过1M。

10、ServiceManager的特殊之处：
1）、对于ServiceManager这个Server来说，Client如果想要获得ServiceManager远程接口，不必通过进程间通信机制来获得，因为ServiceManager远程接口是一个特殊的Binder引用，它的引用句柄一定是0。		获取ServiceManager远程接口的函数是defaultServiceManager，这个函数声明在frameworks/base/include/binder/IServiceManager.h文件中。

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$# ----传递给程序的总的参数数目 　
$? ----上一个代码或者shell程序在shell中退出的情况，如果正常退出则返回0，反之为非0值。 　　
$* ----传递给程序的所有参数组成的字符串。 　　
$n ----表示第几个参数，$1 表示第一个参数，$2 表示第二个参数 ... 　　$0 ----当前程序的名称
$@----以"参数1" "参数2" ... 形式保存所有参数 　　
$$ ----本程序的(进程ID号)PID 　　
$! ----上一个命令的PID
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TMUX
tmux默认的快捷键前缀是Ctrl+b(下文用prefix指代)，按下前缀组合键后松开，再按下命令键进行快捷操作，比如使用prefix d分离会话（应该写作prefix d而不是prefix+d，因为d键不需要与prefix同时按下）。
-----------------------
常用命令
tmux new -s mysession　　创建名为mysession的会话

tmux ls　　显示会话列表

tmux a -t mysession　　连接指定会话

tmux kill-server　　关闭所有会话

-------------------

tmux new　　创建默认名称的会话（在tmux命令模式使用new命令可实现同样的功能，其他命令同理，后文不再列出tmux终端命令）

tmux new -s mysession　　创建名为mysession的会话

tmux ls　　显示会话列表

tmux a　　连接上一个会话

tmux a -t mysession　　连接指定会话

tmux rename -t s1 s2　　重命名会话s1为s2

tmux kill-session　　关闭上次打开的会话

tmux kill-session -t s1　　关闭会话s1

tmux kill-session -a -t s1　　关闭除s1外的所有会话

tmux kill-server　　关闭所有会话

常用快捷键

prefix s　　列出会话，可进行切换

prefix $　　重命名会话

prefix d　　分离当前会话

prefix D　　分离指定会话

　　

窗口管理
prefix c　　创建一个新窗口

prefix ,　　重命名当前窗口

prefix w　　列出所有窗口，可进行切换

prefix n　　进入下一个窗口

prefix p　　进入上一个窗口

prefix l　　进入之前操作的窗口

prefix 0~9　　选择编号0~9对应的窗口

prefix .　　修改当前窗口索引编号

prefix '　　切换至指定编号（可大于9）的窗口

prefix f　　根据显示的内容搜索窗格

prefix &　　关闭当前窗口

　

窗格管理
prefix %　　水平方向创建窗格

prefix "　　垂直方向创建窗格

prefix Up|Down|Left|Right　　根据箭头方向切换窗格

prefix q　　显示窗格编号

prefix o　　顺时针切换窗格

prefix }　　与下一个窗格交换位置

prefix {　　与上一个窗格交换位置

prefix x　　关闭当前窗格

prefix space(空格键)　　重新排列当前窗口下的所有窗格

prefix !　　将当前窗格置于新窗口

prefix Ctrl+o　　逆时针旋转当前窗口的窗格

prefix t　　在当前窗格显示时间

prefix z　　放大当前窗格(再次按下将还原)

prefix i　　显示当前窗格信息

 

　　

其他命令
tmux list-key　　列出所有绑定的键，等同于prefix ?

tmux list-command　　列出所有命令

　　

以上为tmux的常见操作，基本可以满足大部分的工作需求，至于更高端的操作待日后再整理。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
adb 命令：

一、读取系统相关值

1.数据库的值.

      以读写屏幕亮度为例，亮度值保存在settings数据库中的system表中：

      读：adb shell settings get system screen_brightness ；

      写：adb shell settings put system screen_brightness 150；

     此命令需要知道值存在哪个数据库，哪张表里面。

2. 系统SystemProperties值.

   例如系统语言persist.sys.locale：

   读取 ：adb shell getprop persist.sys.locale ；

    写入：adb shell setprop persist.sys.locale en-US ； (ro开头的值属于 read only，无法写入)

二、模拟系统按键、点击、滑动事件

   按键事件：adb shell input keyevent 26 ;（常用键值：26=power，3=home，4=back，其他按键值可参考KeyEvent.java中的定义）

   点击事件：adb shell input tap 1070 1824 ;（1070 1824分别为屏幕的x、y坐标）

   滑动事件：adb shell input swipe 1070 1824 250 250 ;（红色1070 1824为起始坐标，250 250为终点坐标）

   输入事件：adb shell input text "wifi" ;（可向文本框中输入字符串，文本框需获取焦点才有作用）

三、重启android

adb shell stop;

adb shell start;

只重启Android，不会重启kernel

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------驱动打印调用栈：
1.在内核中代码调用过程难以跟踪，上下文关系复杂，确实让人头痛

调用dump_stack()就会打印当前cpu的堆栈的调用函数了。

如此，一目了然的就能看到当前上下文环境，调用关系了

2.在hal层C++代码中的话，可以复制如下代码

#include <utils/CallStack.h>
#define CALLSTACK() \
{ \
ALOGD("CALL STACK : - %s", __FUNCTION__); \
android::CallStack stack; \
stack.update(); \
ALOGD("\t%s", stack.toString("").string()); \
}

然后调用 CALLSTACK()即可
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

[AP000008]系统属性(System Property)详解
转至元数据结尾
由 未知用户 (jie.sun)创建于七月 11, 2017转至元数据起始
一、System Property使用限制
System Property的buffer分成三块：
Head块固定32个字节;
Info块存放property name的简单hash值，每个4个字节;
Data区存放property的key<->value真实数据，每个128个字节;
android 4.4以后，Google已经使用Hybird trie/binary tree结构代替了原来的线性结构，性能大为提升，对应的system property数量也大为提升，但是还是有一定限制的。
1、在alps/bionic/libc/include/sys/_system_properties.h中定义了
#define PA_SIZE (128 * 1024)
限制了整个System Property buffer大小，默认不能超出此限制。
2、在alps/bionic/libc/include/sys/system_properties.h中定义了
#define PROP_NAME_MAX 32
#define PROP_VALUE_MAX 92
限制了每个System Property name/value的字符最大长度
3、权限限制
见System Property的使用
二、常见System Property
1、编译生成的prop，此类prop数据是disk存储，重启或者恢复出厂设置数据重新加载，所以不会丢失
最常见的prop：default.prop、system/build.prop。它们在build的时候即填写好，然后保存在手机系统中。
default.prop中的属性属于系统安全属性，通常请下严禁在运行时修改，由build时的变量ADDITION_DEFAULT_PROPERTIES产生，如ro.secure，ro.debuggable等。
具体可以参考alps/build/core/main.mk中这个ADDITION_DEFAULT_PROPERTIES变量的设置。
system/build.porp中的属性称为常规属性，由build时的变量ADDITION_BUILD_PROPERTIES产生，通常可以在如build/tools/buildinfo.sh、alps/maisui/[project]/system.prop中添加，或者直接修改ADDITION_BUILD_PROPERTIES变量。建议在system.prop中添加。
2、persist开头prop
这类prop存储在/data/property当中，重启后数据依然可以重新加载，但是由于在data分区，恢复出厂后数据会丢失，需要重新生成
3、ro开头的prop
这类prop只可以设置一次值，一旦值设置成功后不能再更新
4、还有一类prop值不是disk存储，仅仅存储在init进程的内存中，一旦重启数据就丢失。
其实运行时，所有的prop值都是存储init进程中，下面会讲到。
三、System Property的加载
在alps/bionic/libc/include/sys/_system_properties.h中定义了各种System Property的存储路径
#define PROP_PATH_RAMDISK_DEFAULT "/default.prop"
#define PROP_PATH_SYSTEM_BUILD "/system/build.prop"
#define PROP_PATH_VENDOR_BUILD "/vendor/build.prop"
#define PROP_PATH_LOCAL_OVERRIDE "/data/local.prop"
#define PROP_PATH_FACTORY "/factory/factory.prop"
开机后由init进程开启property_service服务，在alps/system/core/init/init.cpp调用alps/system/core/init/property_service.cpp中start_property_service()
property_service起来后由load_persistent_properties()载入所有prop文件，所有System Property的set/get由property_service统一管理。如需调试编译bootimage即可
对于一般的system property只是保存在init的内存中, 不会更新disk中的数据，一旦掉电即丢失；对于以persist开头的持久化的系统属性，因为结果是保存在data分区，通常在恢复出厂设置时因为data 分区被清掉，就也会丢失。
四、System Property的使用
1、常见使用场景
CPP:
#include <cutils/properties.h>
property_set("cus.recoveryadb.prop", "1");
char test[PROPERTY_VALUE_MAX];
property_get("cus.recoveryadb.prop", test, "0");
LOG1("prop test =%d %s \n", atoi(test), test);
JAVA:
import android.os.SystemProperties;
SystemProperties.getInt("cus.recoveryadb.prop", 0);
SystemProperties.set("cus.recoveryadb.prop", "1");
init.rc:
on property:vold.decrypt=trigger_shutdown_framework
write /proc/bootprof "INIT:vold.decrypt=trigger_shutdown_framework"
start stop_modem
start swapoff_action
stop stp_dump
setprop sys.boot_completed 0
setprop dev.bootcomplete 0
2、使用举例
SystemProperties.set("sys.test.aaa", “111”);//get值为111，重启后get值为空
SystemProperties.set("persist.radio.test", “111”);//get值为111，重启后get值为111
SystemProperties.set("persist.sys.test", “111”);//get值为111，重启后get值为111
SystemProperties.set("persist.temp.test", “111”);//get值为空，重启后get值为空
SystemProperties.set("test.lcm.clk", “111”);//get值为空，重启后get值为空
SystemProperties.set("ro.lcm.clk", “111”);//get值为空，重启后get值为空
以上为6组实验数据，对此结果是否有疑惑呢？
为什么有些prop设置后还是空？为什么有些prop原来有值，重启后为空？
先来分析第一个问题，为什么有些prop设置后还是空？
这涉及到selinux权限问题，抓取上面代码的执行的mtklog，查看kernel_log有如下异常：
init: avc: denied { set } for property=persist.temp.test pid=3338 uid=1001 gid=1001 scontext=u:r:radio:s0 tcontext=u:object_r:default_prop:s0 tclass=property_service permissive=0
init: sys_prop: permission denied uid:1001 name:persist.temp.test
看到此log，第一反应是在radio.te添加：
allow radio default_prop:property_service { set };
如此添加后，直接编译报错，因为property.te文件有如下限制：
neverallow { domain -init } default_prop:property_service set;
即除了init进程，不允许添加default_prop的set权限。
到此，是否会有更多的疑问？如果是权限问题，为什么“sys.test.aaa”/“persist.radio.test”/"persist.sys.test"是可以的，而“persist.temp.test”/"test.lcm.clk"/"ro.lcm.clk"是不行的？
要是修改neverallow规则，估计也是可以强制写入成功的，但是不管这样做是否会引入问题，已经违背了google的原生设计了，实在不是明智的选择。
google引入neverallow规则，是跟selinux权限机制对应的，一方面给予进程相应的权限，另一方面防止进程的权限放大问题，因为selinux权限不是本文重点，故不做深入分析。
回到刚才的问题？为什么“sys.test.aaa”/“persist.radio.test”/"persist.sys.test"是可以的，而“persist.temp.test”/"test.lcm.clk"/"ro.lcm.clk"是不行的？
搜索代码后发现，alps/system/sepolicy/property_contexts文件中定义了各种“合法”的prop形式，
显然“sys.test.aaa”/“persist.radio.test”/"persist.sys.test"是“合法”的，而“persist.temp.test”/"test.lcm.clk"/"ro.lcm.clk"是“不合法”的
如此的话，解决方法有两个：一个是修改prop的名称使其合法，这个简单不用说了；二是是自己的prop合法，参考第三点
再来分析第二个问题，为什么有些prop原来有值，重启后为空？
这个问题其实前面的内容已经有说到了，以persist开头的prop值是存储在/data/property/中，每次重启后property_service会重新从文件加载prop属性值，故重启后值还在；而普通的"sys.test.aaa"，它的值只是临时存储在init进程中，重启后值不在了
3、如何自定义添加prop值
property_contexts添加
cus.recoveryadb.prop u:object_r:cus_recoveryadb_prop:s0
property.te添加
type cus_recoveryadb_prop, property_type;
修改对应的te文件，比如recovery中使用，则修改recovery.te，添加
allow recovery cus_recoveryadb_prop:property_service set;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
OTA:
一、ota应用层：
1、上层根据更新包进行更新关键的几个类：
\frameworks\base\core\java\android\os\RecoverySystem.java
:
processPackage();  
installPackage();



/frameworks/base/services/core/java/com/android/server/RecoverySystemService.java
:
uncrypt();
setupBcb(String command);//通过socket写入command信息



/frameworks/base/services/core/java/com/android/server/power/ShutdownThread.java
:
reboot();————>ShutdownThread.run();



二、Recovery
1、recovery 与android主系统的通讯接口：
Recovery通过/cache/recovery/文件夹下的三个文件与main system通信。
（1） /cache/recovery/command：这个文件保存着Main system传给Recovery的命令行，每一行就是一条命令，支持一下几种的组合。
（2） /cache/recovery/log：Recovery模式在工作中的log打印。
（3） /cache/recovery/intent：Recovery传递给Main system的信息。作用不详。


2、recovery 与 bootloader的通讯接口：
（下面这一部分很重要，要理解）（下面这一部分很重要，要理解）（下面这一部分很重要，要理解）
 BCB是Bootloader与Recovery的通信接口，也是Bootloader与Main system之间的通信接口。存储在flash中的MISC分区。占用三个page，其本身就是一个结构体，详细成员以及各成员含义例如以下，位于/bootloader/revocery/bootloader.h文件里：

struct bootloader_message{

char command[32];

    char status[32];

    char recovery[1024];

};
 command字段：当要重新启动进入Recovery模式或更新radio、bootloader固件时。linux会更新这个值。当固件更新完毕后Bootloader也会更新这个值。另外在成功更新后结束Recovery时。会清除这个成员的值，防止重新启动时再次进入Recovery模式。

 status字段：在完毕对应的更新后。Bootloader会将运行结果写入到这个字段。

 recovery字段：可被Main System写入，也可被Recovery服务程序写入。该文件的内容格式为：

    “recovery\n

    <recovery command>\n

    <recovery command>”

该文件存储的就是一个字符串，必须以recovery\n开头，否则这个字段的全部内容域会被忽略。“recovery\n”之后的部分，是/cache/recovery/command支持的命令。

能够将其理解为Recovery操作过程中对命令操作的备份。Recovery对其操作的过程为：先读取BCB然后读取/cache/recovery/command，然后将二者又一次写回BCB。这样在进入Main system之前。确保操作被运行。在操作之后进入Main system之前。Recovery又会清空BCB的command域和recovery域，这样确保重新启动后不再进入Recovery模式。


3、涉及的类
Z:\code\p\6739\forCompare\WTK6739_P0_MP1_AP\alps\bootable\recovery\recovery.cpp
Z:\code\p\6739\forCompare\WTK6739_P0_MP1_AP\alps\bootable\recovery\install.cpp
Z:\code\p\6739\forCompare\WTK6739_P0_MP1_AP\alps\bootable\recovery\roots.cpp
Z:\code\p\6739\forCompare\WTK6739_P0_MP1_AP\alps\bootable\recovery\updater\updater.cpp

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SystemUI

1、Notification的添加
在NotificationEntryManager中addNotificationInternal()调用createNotificationViews()之后就会去inflate这个notification的row。在inflate完成之后会调用onAsyncInflationFinished()，这里面又会调用addEntry(entry)，就是在这里将这个notification添加完成的。即都保存在mNotificationData中。

至于mPendingNotifications，这里面保存的是还没有完成inflate的notification。

当前分析结果为：mSortedAndFiltered里面保存的应该就是要展开显示给用户看的notifications，其余的应该就显示在shelf中吧？（感觉其余的只是显示了个图标，所以他们的显示是通过iconcontainer实现的）


NotificationViewHierarchyManager这个类是管理notification显示的。

关于notification的分组，notification自身有groupkey这个属性，应该是在NotificationViewHierarchyManager的updateNotificationViews 中进行分组的，分组信息存放在mTmpChildOrderMap中，最后在addNotificationChildrenAndSort()中进行排序。

headsup表示的就是从屏幕顶端弹出显示的notification，比如截图后弹出的。
EmptyShadeView是用来显示 No notification的。
FooterView就是底部的manage notification 和 clear notification。

需要更新notification部分时，一般都是调用EntryManager.updateNotifications()。
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Linux 的命令：
AWK是一种处理文本文件的语言，是一个强大的文本分析工具。
1、awk -F "=" '{print $NF}'  <filename>
意思是：将file或者字符串用等号拆分，并进行输出，print $NF 代码输出最后拆分后的一部分。


SED
sed 命令是利用脚本来处理文本文件。
语法
sed [-hnV][-e<script>][-f<script文件>][文本文件] 而且可以用单引号添加动作
参数说明：

-e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。
-f<script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。
-h或--help 显示帮助。
-n或--quiet或--silent 仅显示script处理后的结果。
-V或--version 显示版本信息。

动作说明：

a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！

还有比较细节的用法，比如：
sed 可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样：

sed 's/要被取代的字串或正则表达式/新的字串/g'
eg:sed  's/[^0-9a-zA-Z= ._-]//g'


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Dart
0、As you learn about the Dart language, keep these facts and concepts in mind:

Everything you can place in a variable is an object, and every object is an instance of a class. Even numbers, functions, and null are objects. All objects inherit from the Object class.

Although Dart is strongly typed, type annotations are optional because Dart can infer types. In the code above, number is inferred to be of type int. When you want to explicitly say that no type is expected, use the special type dynamic.

Dart supports generic types, like List<int> (a list of integers) or List<dynamic> (a list of objects of any type).

Dart supports top-level functions (such as main()), as well as functions tied to a class or object (static and instance methods, respectively). You can also create functions within functions (nested or local functions).

Similarly, Dart supports top-level variables, as well as variables tied to a class or object (static and instance variables). Instance variables are sometimes known as fields or properties.

Unlike Java, Dart doesn’t have the keywords public, protected, and private. If an identifier starts with an underscore (_), it’s private to its library. For details, see Libraries and visibility.

Identifiers can start with a letter or underscore (_), followed by any combination of those characters plus digits.

Dart has both expressions (which have runtime values) and statements (which don’t). For example, the conditional expression condition ? expr1 : expr2 has a value of expr1 or expr2. Compare that to an if-else statement, which has no value. A statement often contains one or more expressions, but an expression can’t directly contain a statement.

Dart tools can report two kinds of problems: warnings and errors. Warnings are just indications that your code might not work, but they don’t prevent your program from executing. Errors can be either compile-time or run-time. A compile-time error prevents the code from executing at all; a run-time error results in an exception being raised while the code executes.


1、关于null
void main() {
  // "if null" operator
  print(null ?? 'New in Dart 1.12');
  
  // null-aware assignment
  var x = null;
  x ??= 'are the null-aware operators, friendly to';
  print(x);
  
  // null-aware method invocation
  var isNull = null;
  print(isNull?.foo()); // null (does not throw exception)
}
有几个处理：
(1)、??             如果前面的变量是null，就用后面的值
(2)、??=            如果前面的变量是null，就用将其赋值为后面的值
(3)、x?.p           如果x不为空，就取得其属性p的值
(4)、x?.m()         如果x不为空，就调用其方法m()




2、async/await , 你能运用它们来按照同步的方式书写异步的代码


3、String

You can put the value of an expression inside a string by using ${expression}. If the expression is an identifier, you can skip the {}. To get the string corresponding to an object, Dart calls the object’s toString() method.

var s = 'string interpolation';

assert('Dart has $s, which is very handy.' ==
    'Dart has string interpolation, ' +
        'which is very handy.');
assert('That deserves all caps. ' +
        '${s.toUpperCase()} is very handy!' ==
    'That deserves all caps. ' +
        'STRING INTERPOLATION is very handy!');
		
		
4、
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Flutter
一、界面
一个Flutter应用本身就是一个widget？？？？？？？

1、A Flutter app is itself a widget, and most widgets have a build() method. Instantiating and returning a widget in the app’s build() method displays the widget.
For a Material app, you can use a Scaffold widget; it provides a default banner, background color, and has API for adding drawers, snack bars, and bottom sheets. 

2、You control how a row or column aligns its children using the mainAxisAlignment and crossAxisAlignment properties. For a row, the main axis runs horizontally and the cross axis runs vertically. For a column, the main axis runs vertically and the cross axis runs horizontally.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Jetpack:

一、ViewModel
1、ViewModel的重心是对 数据状态的维护
2、Google官方建议ViewModel尽量保证 纯的业务代码，不要持有任何View层(Activity或者Fragment)或Lifecycle的引用，这样保证了ViewModel内部代码的可测试性，避免因为Context等相关的引用导致测试代码的难以编写（比如，MVP中Presenter层代码的测试就需要额外成本，比如依赖注入或者Mock，以保证单元测试的进行）
3、





-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
RxJava
一、变换
1、flatMap() 的原理是这样的：1. 使用传入的事件对象创建一个 Observable 对象；2. 并不发送这个 Observable, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。

根本原理在lift()函数，而我的理解是，这个变换过程的真正实现就在operator中完成。正是因为需要变换，才会有operator中的操作，然后生成新的subscriber给真正的订阅者或者往下传递给其它变换。

讲述 lift() 的原理只是为了让你更好地了解 RxJava ，从而可以更好地使用它。然而不管你是否理解了 lift() 的原理，RxJava 都不建议开发者自定义 Operator 来直接使用 lift()，而是建议尽量使用已有的 lift() 包装方法（如 map() flatMap() 等）进行组合来实现需求，因为直接使用 lift() 非常容易发生一些难以发现的错误。



subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 
observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。



几个重要方法代码块：
1、
// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。
// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。
public Subscription subscribe(Subscriber subscriber) {
    subscriber.onStart();
    onSubscribe.call(subscriber);
    return subscriber;
}

2、一个比较完整的RxJava调用过程：（create其实可以换成from 等其它方法）
int drawableRes = ...;
ImageView imageView = ...;
Observable.create(new OnSubscribe<Drawable>() {
    @Override
    public void call(Subscriber<? super Drawable> subscriber) {
        Drawable drawable = getTheme().getDrawable(drawableRes));
        subscriber.onNext(drawable);//这里就是调用的观察者的onNext()方法
        subscriber.onCompleted();
    }
}).subscribe(new Observer<Drawable>() {
    @Override
    public void onNext(Drawable drawable) {
        imageView.setImageDrawable(drawable);
    }

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
        Toast.makeText(activity, "Error!", Toast.LENGTH_SHORT).show();
    }
});


3、lift()的核心代码：
// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。
// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。
public <R> Observable<R> lift(Operator<? extends R, ? super T> operator) {
    return Observable.create(new OnSubscribe<R>() {
        @Override
        public void call(Subscriber subscriber) {
            Subscriber newSubscriber = operator.call(subscriber);
            newSubscriber.onStart();
            onSubscribe.call(newSubscriber);
        }
    });
}

lift是变换了Subscriber，


4、在 RxJava 中， Observable 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe() 方法执行的时候。存在变换时，订阅这个动作是逆向一步一步传上去的。


二、线程控制：










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

一、Java 初始化顺序：
普通类：
静态变量
静态代码块
普通变量
普通代码块
构造函数


继承的子类：
父类静态变量
父类静态代码块
子类静态变量
子类静态代码块
父类普通变量
父类普通代码块
父类构造函数
子类普通变量
子类普通代码块
子类构造函数


抽象的实现子类: 接口 - 抽线类 - 实现类
接口静态变量
抽象类静态变量
抽象类静态代码块
实现类静态变量
实习类静态代码块
抽象类普通变量
抽象类普通代码块
抽象类构造函数
实现类普通变量
实现类普通代码块
实现类构造函数




接口注意：
声明的变量都是静态变量并且是final的，所以子类无法修改，并且是固定值不会因为实例而变化
接口中能有静态方法，不能有普通方法，普通方法需要用defalut添加默认实现
接口中的变量必须实例化
接口中没有静态代码块、普通变量、普通代码块、构造函数






二、java的多态：
1、普通方法是支持多态的
2、类内部定义的域是不支持多态的
3、静态方法也是不支持多态的



三、内部类：
0、分类：成员内部类、局部内部类、匿名内部类和静态内部类。
1、成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。
成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下（即使在当前外部类使用自己的内部类也要这样）：
public class Test {
    public static void main(String[] args)  {
        //第一种方式：
        Outter outter = new Outter();
        Outter.Inner inner = outter.new Inner();  //必须通过Outter对象来创建
         
        //第二种方式：
        Outter.Inner inner1 = outter.getInnerInstance();
    }
}

成员内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。

2、局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。不能有public、protected、private以及static修饰符的。

3、静态内部类：它不能使用外部类的非static成员变量或者方法。
Outter.Inner inner = new Outter.Inner();

局部内部类和匿名内部类只能访问局部final变量。java8取消此限制。


4、访问外部类的成员：
class Outter
{
    private int a = 1;
    class Inner {
        private int a = 2;
        public void print() {
            int a = 3;
            System.out.println("局部变量：" + a);
            System.out.println("内部类变量：" + this.a);
            System.out.println("外部类变量：" + Outter.this.a);
        }
    }
}

5、为什么在Java中需要内部类？总结一下主要有以下四点：

　　1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，

　　2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。

　　3.方便编写事件驱动程序

　　4.方便编写线程代码


四、泛型
1、java的泛型只在编译阶段有效。
在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。


2、泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法



五、并发
1、线程
1）、线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。
　　说简单点的：对于线程的上下文切换实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。

2）、yield()方法也不会释放锁!!!!!!!!!!!

3)、join方法
实际上调用join方法是调用了Object的wait方法。

有三个重载版本：
join()
join(long millis)     //参数为毫秒
join(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒

4）、
单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，也就说，它可以用来中断一个正处于阻塞状态的线程，但，直接调用interrupt方法不能中断正在运行中的线程。

2、线程协作
1）、如果调用某个对象的wait()方法，当前线程必须拥有这个对象的monitor（即锁），因此调用wait()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。
调用某个对象的notify()/notifyAll()方法，当前线程也必须拥有这个对象的monitor，因此调用notify()/notifyAll()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。

要注意一点，一个线程被唤醒不代表立即获取了对象的monitor，只有等调用完notify()或者notifyAll()并退出synchronized块，释放对象锁后，其余线程才可获得锁执行。

2）、　　Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作。

相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition。

Condition是个接口，基本的方法就是await()和signal()方法；
Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() 
 调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用
　　Conditon中的await()对应Object的wait()；

　　Condition中的signal()对应Object的notify()；

　　Condition中的signalAll()对应Object的notifyAll()。

Lock 接口：
public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}


几种锁：
ReentrantLock

　　ReentrantLock，意思是“可重入锁”。





Condition 接口：
public interface Condition {
    void await() throws InterruptedException;
    void awaitUninterruptibly();
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    boolean await(long time, TimeUnit unit) throws InterruptedException;
    boolean awaitUntil(Date deadline) throws InterruptedException;
    void signal();
    void signalAll();
}



3）、Lock和synchronized的选择

　　总结来说，Lock和synchronized有以下几点不同：

　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；

　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；

　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；

　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。

　　5）Lock可以提高多个线程进行读操作的效率。

　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。

3、
每个ThreadLocal变量保存一个实际变量，比如Looper。而每个Thread中有一个ThreadLocalMap类型的变量threadlocals可以用来保存这个thread中所有的ThreadLocal变量。

在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------传感器：

1、在Android系统中，传感器系统的Frameworks层的代码路径是：framework/base/core/java/android/hardware

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
蓝牙：
1、
Android平台中蓝牙系统从上到下主要包括Java框架中的BlueTooth类、Android适配库、BlueZ库、驱动程序和协议这几部分。

2、
为了让支持蓝牙的设备能够在彼此之间传输数据，它们必须先通过配对过程形成通信通道。其中一台设备（可检测到的设备）需将自身设置为可接收传入的连接请求。另一台设备会使用服务发现过程找到此可检测到的设备。在可检测到的设备接受配对请求后，这两台设备会完成绑定过程，并在此期间交换安全密钥。二者会缓存这些密钥，以供日后使用。完成配对和绑定过程后，两台设备会交换信息。当会话完成时，发起配对请求的设备会发布已将其链接到可检测设备的通道。但是，这两台设备仍保持绑定状态，因此在未来的会话期间，只要二者在彼此的范围内且均未移除绑定，便可自动重新连接。



3、Android 设备默认处于不可检测到状态。用户可通过系统设置将设备设为在有限的时间内处于可检测到状态，或者，应用可请求用户在不离开应用的同时启用可检测性。

被配对与被连接之间存在区别：
被配对是指两台设备知晓彼此的存在，具有可用于身份验证的共享链路密钥，并且能够与彼此建立加密连接。
被连接是指设备当前共享一个 RFCOMM 通道，并且能够向彼此传输数据。当前的 Android Bluetooth API 要求规定，只有先对设备进行配对，然后才能建立 RFCOMM 连接。在使用 Bluetooth API 发起加密连接时，系统会自动执行配对。

4、BLE
1）、当用户使用 BLE 将其设备与其他设备配对时，用户设备上的所有应用都可以访问在这两个设备间传输的数据。因此，如果您的应用捕获敏感数据，您应实现应用层安全以保护此类数据的私密性。

您仅能扫描蓝牙 LE 设备或传统蓝牙设备，正如蓝牙概览中所述。您无法同时扫描蓝牙 LE 设备和传统蓝牙设备。

2）、如果您要声明您的应用仅适用于支持 BLE 的设备，请在应用清单中添加以下内容：
<uses-feature android:name="android.hardware.bluetooth_le" android:required="true"/>
如果您希望应用适用于不支持 BLE 的设备，则您应仍将此元素添加到应用清单中，但设置 required="false"。然后您可以在运行时使用 PackageManager.hasSystemFeature() 确定 BLE 的可用性：
// Use this check to determine whether BLE is supported on the device. Then
// you can selectively disable BLE-related features.
if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
    Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show();
    finish();
}

3）、BluetoothGattCharacteristic
对于BLE，真正进行数据传输都是通过BluetoothGattCharacteristic。过蓝牙发送数据给外围设备就是往这些 Characteristic 中的 Value 字段写入数据；外围设备发送数据给手机就是监听这些 Charateristic 中的 Value 字段有没有变化，如果发生了变化，手机的 BLE API 就会收到一个监听的回调。





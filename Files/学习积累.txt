1、使用fragment避免配置变化导致生命周期运行而使程序混乱：
Activity 中：（如果是直接在某个布局中固定的fragment，就不用做处理）
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        Log.d(TAG, this + ": onCreate()");


        TextView tv = new TextView(this);
        tv.setText("Hello world");
        setContentView(tv);

        if (getFragmentManager().findFragmentByTag("test_fragment") == null)
        {
            Log.d(TAG, this + ": Existing fragment not found.");
            FragmentTransaction ft = getFragmentManager().beginTransaction();
            ft.add(new TestFragment(), "test_fragment").commit();
        }
        else
        {
            Log.d(TAG, this + ": Existing fragment found.");
        }
    }
		
		
Fragment中：

  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Retain this fragment across configuration changes.
    setRetainInstance(true);
	｝
	
	  @Override
  public void onAttach(Activity activity) {
    super.onAttach(activity);
    mContext = (TaskCallbacks) activity;
  }
  
    @Override
  public void onDetach() {
    super.onDetach();
    mContext = null;
  }

当配置发生改变时，MainActivity正常走生命周期的重构方法，一旦新的Activity创建成功后会回调Fragmentd的onAttach(Activity)方法，即使在配置改变的情况下，保证Fragment当前持有的是最新的Activity的引用。
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2、
API 14及以上
用Application.onTrimLevel(int level)和TRIM_MEMORY_UI_HIDDEN判断应用是否切换至后台运行。
通过INTENT.ACTION_SCREEN_OFF注册广播接受器监听屏幕熄灭
注册Activity.registerLifeStyleCallback监听应用切换至前台运行

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3、通过这个命令查看手机的服务名称列表
adb shell service list
然后就可以dump需要的service的信息了



而对于特定的service，可以用-h查看具体命令，比如package这个服务：
$ adb shell dumpsys package -h
Package manager dump options:
  [-h] [-f] [--checkin] [cmd] ...
    --checkin: dump for a checkin
    -f: print details of intent filters
    -h: print this help
  cmd may be one of:
    l[ibraries]: list known shared libraries
    f[eatures]: list device features
    k[eysets]: print known keysets
    r[esolvers] [activity|service|receiver|content]: dump intent resolvers
    perm[issions]: dump permissions
    permission [name ...]: dump declaration and use of given permission
    pref[erred]: print preferred package settings
    preferred-xml [--full]: print preferred package settings as xml
    prov[iders]: dump content providers
    p[ackages]: dump installed packages
    s[hared-users]: dump shared user IDs
    m[essages]: print collected runtime messages
    v[erifiers]: print package verifier info
    d[omain-preferred-apps]: print domains preferred apps
    i[ntent-filter-verifiers]|ifv: print intent filter verifier info
    version: print database version info
    write: write current settings now
    installs: details about install sessions
    check-permission <permission> <package> [<user>]: does pkg hold perm?
    dexopt: dump dexopt state
    compiler-stats: dump compiler statistics
    service-permissions: dump permissions required by services
    <package.name>: info about given package


adb 查看进程信息？ adb shell dumpsys activity p

adb 查看某个package的状态信息：adb shell dumpsys activity package <com.android.systemui>


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ContextImpl有三种不同的类型：

SystemContext：系统进程SystemServer的Context
AppContext：应用进程的Context
ActivityContext：Activity的Context，只有ActivityContext跟界面显示相关，需要传入activityToken和有效的DisplayId


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
管道：

管道有匿名管道和命名管道，匿名用于亲缘进程通信，而命名可以任意进程间进行通信。

管道的原理: 
管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。

一、匿名管道：

特点：

1.管道只允许具有血缘关系的进程间通信，如父子进程间的通信。

2.管道只允许单向通信。

3.管道内部保证同步机制，从而保证访问数据的一致性。

4.面向字节流

5.管道随进程，进程在管道在，进程消失管道对应的端口也关闭，两个进程都消失管道也消失。


局限性：

① 数据自己读不能自己写。

② 数据一旦被读走，便不在管道中存在，不可反复读取。

③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。

④ 只能在有公共祖先的进程间使用管道。

常见的通信方式有：

单工通信、半双工通信、全双工通信。

二、

三、





--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
先说一下SystemServer这个类：
它主要的工作就是：启动各个Service。
1、由于各Service间有依赖关系，所以有前后顺序。
2、Service的启动是其初始化，后面会有对systemReady的调用，是Service启动完毕需要的一系列操作，以及达到此service启动完毕时要完成的事情（比如AMS中要发送系统启动完成的广播？要启动SystemUI、启动Launcher？）。



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Window 与 View


0、需要重点理解的几个属性
1）、mWindowSession它是通过WindowManagerGlobal.getWindowSession获得的一个Binder服务代理（通过WMS的代理在服务端open一个Session，并在APP端获取该Session的代理），是App端向WMS发送消息的通道。
相对的，mWindow是一个W extends IWindow.Stub Binder服务对象，其实可以看做是App端的窗口对象，主要作用是传递给WMS，并作为WMS向APP端发送消息的通道，在Android系统中存在大量的这种互为C\S的场景。

2）、WindowToken理解成是一个显示令牌（重点是里面的IBinder类型的token属性），无论是系统窗口还是应用窗口，添加新的窗口的时候必须使用这个令牌向WMS表明自己的身份。添加窗口的时候会创建WindowToken，销毁窗口的时候移除WindowToken(removeWindowToken方法)。WindowToken将同一个应用组件(Activity,InputMethod,Wallpaper,Dream)及其内部的窗口组织在一起，换句话说，每一个应用组件的窗口都会对应一个WindowToken，并且这个窗口中的所有子窗口将会对应同一个WindowToken。WindowToken和WindowState是１对多的关系。
token是一个IBinder对象，IBinder在实体端与代理端会相互转换，这里只看实体端，它的取值只有两种:ViewRootImpl中ViewRootImpl.W，或者是ActivityRecord中的IApplicationToken.Stub对象。

3）、WindowState 这个类中比较重要的两个属性：
mSession：指向一个类型为Session的Binder本地对象，使用参数s来初始化，表示当前所创建的WindowState对象是属于哪一个应用程序进程的,Session是进程唯一的。就是用于IPC的windowSession的Binder实体。
mClient：指向一个实现了IWindow接口的Binder代理对象，它引用了运行在应用程序进程这一侧的一个类型为W的Binder本地对象，使用参数c来初始化，通过它可以与运行在应用程序进程这一侧的Activity组件进行通信。就是Client端的mWindow（那个W类）。

4）、WindowManager.LayoutParams有两个很重要的参数type与token。type用来描述窗口的类型，而token其实是标志窗口的分组。

在SurfaceFlinger服务中，每一个SharedBufferStack都对应一个Surface，即一个窗口。


1、WMS的窗口分组有时候会对开发带来影响，如果不知道窗口分组管理，可能有点迷惑，比如Dialog必须使用Activity的Context，PopupWindow不能作为父窗口，尤其要避免作为Webview的容器等，这些都跟WMS窗口的组织有关系。
Android中的窗口主要分为三种：系统窗口、应用窗口、子窗口，Toast就属于系统窗口，而Dialog、Activity属于应用窗口，不过Dialog必须依附Activity才能存在。PopupWindow算是子窗口，必须依附到其他窗口，依附的窗口可以使应用窗口也可以是系统窗口，但是不能是子窗口。
在三种 Window 中，应用 Window 层级范围是 1~99，子 Window 层级范围是 1000~1999，系统 Window 层级范围是 2000~2999。比如StatusBar是系统窗口，对应层级是FIRST_SYSTEM_WINDOW（=2000），Navigationbar也是系统窗口，对应层级是FIRST_SYSTEM_WINDOW+19。
对于应用程序而言，我们理论上是无法创建系统Window，因为没有权限，这个权限只有系统进程有。
（1）、插曲：
WMS使用Choreographer负责所有的窗口动画和屏幕旋转动画，墙纸动画的渲染，用法跟Handler有点类似，他们都是在后期某个时机传入Runable对象，但是他们的回调时机不一样，Handler的处理时机取决与消息队列的处理情况，各个Message的时间都可能不同，而Choreograpoher的回调时机是下一次的VSYNC(垂直刷新同步)，如果在当前时机没有处理完成就会造成失帧，造成造成失帧的原因往往是因为我们布局写的太过复杂，导致16ms内没有完成。 
在KeyguardBouncer中调用mShowRunnable 和 mResetRunnable就用到了Choreographer。

2、WindowManagerService是负责Android的窗口管理，但是它其实只负责管理，比如窗口的添加、移除、大小调整、顺序调整、分组等等（当然，WMS的作用不仅只是管理窗口，它还负责窗口动画、Touch事件等。）。WMS更像在更高的层面对于Android窗口的一个抽象，真正完成图像绘制的是APP端，而完成图层合成的是SurfaceFlinger服务。
单单从窗口显示来看，WMS的作用确实很明确，就是在服务端登记当前存活窗口，后面还会看到，这会影响SurfaceFlinger的图层混合，可以说是为SurfaceFlinger服务的。

3、View必须被添加到窗口中，才会被绘制，或者可以这样理解，只有申请了依附窗口，View才会有可以绘制的目标内存。当APP通过WindowManagerService的代理向其添加窗口的时候，WindowManagerService除了自己进行登记整理，还需要向SurfaceFlinger服务申请一块Surface画布，其实主要是画布背后所对应的一块内存，只有这一块内存申请成功之后，APP端才有绘图的目标（每个view都有自己的onDraw()方法），并且这块内存是APP端同SurfaceFlinger服务端共享的，这就省去了绘图资源的拷贝。
具体过程可以理解为：
每个Activity可以看做是一个图层，其对应一块绘图表面其实就是Surface，Surface绘图表面对应的内存其实是由SurfaceFlinger申请的，并且，内存是APP与SurfaceFlinger间进程共享的。实现机制是基于Linux的共享内存，其实就是MAP+tmpfs文件系统，你可以理解成SF为APP申请一块内存（通过WMS），然后通过binder将这块内存相关的信息传递APP端，APP端往这块内存中绘制内容，绘制完毕，通知SF图层混排，之后，SF再将数据渲染到屏幕。

4、其实整个Android窗口管理简化的话可以分为以下三部分

WindowManagerService：WMS控制着Surface画布的添加与次序，动画还有触摸事件
SurfaceFlinger：SF负责图层的混合，并且将结果传输给硬件显示
APP端：每个APP负责相应图层的绘制，
APP与SurfaceFlinger通信：APP与SF图层之间数据的共享是通过匿名内存来实现的。

作者：看书的小蜗牛
链接：https://juejin.im/post/599cee016fb9a02484491e3e
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

5、关于添加window
1）、我们调用的windowManager.addView其实是调用的WindowManagerGlobal（通过windowManagerImpl调用）的addView方法。而这里面最重要的角色就是ViewRootImpl（这还在app端，因为还没有进行IPC调用）。每次调用windowManager的addView都会创建一个ViewRootImpl。
addView中会调用root.setView()，进一步调用mWindowSession.addToDisplay()，这里IPC调用到com.android.server.wm.Session.addToDisplay()——>WMS.addWindow()。而addWindow()中又会创建对应的WindowState，并通过WindowState.attach()创建SurfaceSession。

2）、ViewRootImpl相当于是MVC模型中的Controller，它有以下职责：1. 负责为应用程序窗口视图创建Surface。 2. 配合WindowManagerService来管理系统的应用程序窗口。 3. 负责管理、布局和渲染应用程序窗口视图的UI。

3）、窗口的插入还是比较复杂的，总结而言:
1.非应用窗口依据mBaseLayer插入，越高越靠前，墙纸和输入法会有特殊处理，在下面还会进行调整。
2.应用窗口参考activity的位置插入，通常应该被插入在其activity所在task的顶部或者该activity上面的activity的最后一个窗口的下面
3.子窗口依据mSubLayer插入
最终插入的地方有两个：DisplayContent所持有的记录该屏幕下所有窗口顺序的WindowList，以及新窗口的WindowToken所记录的所有属于它的WindowState中的WindowList列表。

这是androidN之前的方式了，从androidO开始有了改变，好像的直接通过WindowToken来分析window的层级了。所以addWindow中创建WindowToken用的构造方法参数变多了，而且调用了win.mToken.addWindow(win);利用了WindowToken类中的属性WindowList。

6、关于stack：
Stack对应WindwoManagerService中的TaskStack类，如果是在ActivityManagerService就对应ActivityStack类，为什么要引入TaskStack和ActivityStack类呢？因为他们的作用是管理TASK,一个Stack中包含了多个Task。应用程序也可以在AndroidManifest.xml文件中通过android:launchMode指定当前Activity运行在哪一个Task中。

默认的几个Stack:
Id等于0：Home Stack，就是Launcher所在的Stack。但是还有一些系统界面也运行在这个Stack上，比如近期任务的界面。
Id等于1：FullScreen Stack，全屏的Activity所在的Stack。但其实在分屏模式下，Id为1的Stack只占了半个屏幕。
Id等于2：Freeform模式的Activity所在Stack
Id等于3：Docked Stack　在分屏模式下，屏幕有一半运行了一个固定的应用，这就是Docked Stack
Id等于4：Pinned Stack 这是画中画Activity所在的Stack



18、窗口Z轴的位置
WindowState中一个属性为mLayer，表示窗口在Ｚ轴的位置，mLayer值越小，窗口越靠后，mLayer值越大，窗口越靠前，最前面的一个窗口就作为焦点窗口，可以接收触摸事件。mLayer的值不是固定不变的。mLayer是通过WindowState的另一个成员变量mBaseLayer的值计算得到，mBaseLayer的值是固定不变的，只和窗口类型有关。
窗口的Z轴位置除了跟mBaseLayer有关与之外，还跟窗口在堆栈中的位置有关。

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PowerManagerService
一、WakeLock
1、分类：
WakeLock分为app层、PMS层、native层，这三者分别用不同的锁类型进行表述，且之间有对应关系。
app层虽然都叫WakeLock，但实际对应的flag很多，比如PowerManager.PARTIAL_WAKE_LOCK。
PMS层都是WakeLock这一种(名字与app层相同)。
native层是SuspendBlocker（在PMS中其实只用了对应的两个实例对象：mWakeLockSuspendBlocker锁  和  mDisplaySuspendBlocker锁）

当申请了PARTIAL_WAKE_LOCK类型的WakeLock锁、DRAW_WAKE_LOCK类型的WakeLock锁(前提是处于Doze模式)、屏幕处于唤醒、屏保时，都会持有一个mWakeLockSuspendBlocker锁，会在/sys/power/wake_lock 节点中写入”PowerManager.WakeLocks“，从而保持设备处于唤醒状态。

还有一种比较特殊的锁：
PowerManagerService.Broadcasts锁
这个类型的SuspendBlocker并没有在PMS中进行实例化，它以构造方法的形式传入了Notifier中，Notifier类相当于是PMS的”中介“，PMS中和其他服务的部分交互通过Notifier进行，还有比如亮屏广播、灭屏广播等，都是由PMS交给Notifier来发送，这点在下篇文章中进行分析。因此，如果CPU在广播发送过程中进入休眠，则广播无法发送完成，因此，需要一个锁来保证Notifier中广播的成功发送，这就是PowerManagerService.Broadcasts 锁的作用，当广播发送完毕后，该锁立即就释放了。

2、app层WaleLock的级别：
//如果持有该类型的wakelock锁，则按Power键灭屏后，即使允许屏幕、按键灯灭，也不会释放该锁，CPU不会进入休眠状态
public static final int PARTIAL_WAKE_LOCK;
//Deprecated，如果持有该类型的wakelock锁，则使屏幕保持亮/Dim的状态，键盘灯允许灭，按Power键灭屏后，会立即释放
public static final int SCREEN_DIM_WAKE_LOCK;
//Deprecated，如果持有该类型的wakelock锁，则使屏幕保持亮的状态，键盘灯允许灭，按Power键灭屏后，会立即释放
public static final int SCREEN_BRIGHT_WAKE_LOCK
//Deprecated，如果持有该类型的wakelock锁，则使屏幕、键盘灯都保持亮，按Power键灭屏后，会立即释放
public static final int FULL_WAKE_LOCK
//如果持有该锁，则当PSensor检测到有物体靠近时关闭屏幕，远离时又亮屏，该类型锁不会阻止系统进入睡眠状态，比如
//当到达休眠时间后会进入睡眠状态，但是如果当前屏幕由该wakelock关闭，则不会进入睡眠状态。
public static final int PROXIMITY_SCREEN_OFF_WAKE_LOCK
//如果持有该锁，则会使屏幕处于DOZE状态，同时允许CPU挂起，该锁用于DreamManager实现Doze模式，如SystemUI的DozeService
public static final int DOZE_WAKE_LOCK
//如果持有该锁,则会时设备保持唤醒状态，以进行绘制屏幕，该锁常用于WindowManager中，允许应用在系统处于Doze状态下时进行绘制
public static final int DRAW_WAKE_LOCK


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Activity:
1、一开始从ActivityThread中的handleLaunchActivity方法开始分析，首先加载Activity的字节码文件，利用反射的方式创建一个Activity对象，调用Activity对象的attach方法，在attach方法中，创建系统需要的Window并为设置回调，这个回调定义在Window之中，由Activity实现，当Window的状态发生变化的时候，就会回调Activity实现的这些回调方法。调用attach方法之后，Window被创建完成，这时候需要关联我们的视图，在handleLaunchActivity中的attach执行之后就要执行handleLaunchActivity中的callActivityOnCreate，在onCreate中我们会调用setContentView方法。通过setContentView，创建了Activity的顶级View---DecorView，DecorView的内容栏（mContentParent）用来显示我们的布局，这只是添加的过程，还要有一个显示的过程，显示的过程就要调用ActivityThead中handleLaunchActivity中的handleResumeActivity方法了，最后会调用makeVisible方法，把这个DecorView显示出来。
这是之前的流程，现在生命周期有特定的类管理了。

2、什么是Activity的切换呢？　 
前一个Activity从resume状态变成pause状态，后一个Activity进入到resume状态，将前一个resume状态的窗口设置成不可见，后一个窗口设置成可见。

切换的步骤:
ActivityStack类的成员函数startActivityLocked首先会给正在启动的Activity组件准备一个切换操作，这里所说的切换操作，你可以理解成前面设置的动画类型。
接着再调用其它的成员函数来通知前一个激活的Activity组件进入到Paused状态。
等到前一个激活的Activity组件进入到Paused状态之后，ActivityManagerService服务就会检查用来运行正在启动的Activity组件的进程启动起来了没有。如果这个进程还没有启动，那么ActivityManagerService服务就会将该进程启动起来，然后再调用ActivityStack类的成员函数realStartActivityLocked来将正在启动的Activity组件加载起来，并且将它的状态设置为Resumed。这里面具体又分成两个小点，一是setAppVisibility 、二是通知lauch Activity。
最后通知WindowManagerService服务执行前面所准备的切换操作（这里就包括了对应的动画的执行）。



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

JNI
1、JNIEnv*  这是一个与线程相关的变量。是用来操作Java层的。

它就是提供了一些JNI系统函数。通过这些函数，可以 调用java函数   和  操作jobject对象  等等。



--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
C++

一、
1、内联函数
类的成员函数可以在类内实现也可以只在类内部声明，在类外部实现。
他们主要的区别在于，
类内实现的成员函数有可能被编译器优化为内联函数，
而类外的就得加关键字inline。
这里要注意的是，及时加入了inline或者是在类内实现的成员函数，
也不一定能够成为内联函数，如果编译器觉得函数太复杂就不内联了。

一般的比较短小的函数写在类内做内联还是比较好的。
写在类外有利于隐藏实现的细节，达到保护的作用。
一般的类库只提供头文件，即类的定义，而类的实现就不告诉你了，
编译成.dll给你，你就不知道它是怎么实现的了，达到商业保密的作用。

2、当对象生存周期结束时对象被自动撤销, 所占用的内存被回收, 需要注意的是, 如果对象的成员函数中有使用 new 或者 malloc 申请的动态内存程序不会对其进行释放, 需要我们手动进行清理, 否则会造成内存泄露。

3、C++中可以同时using 两个命名空间，但前提是这两个空间中没有相同的变量或函数，否则会提示 "ambiguous symbol"的错误信息。
 eg:
 using namespace std;
 using namespace <自己的命名空间>;
 
 4、
 C++ #include " " 与 <>有什么区别
简言之 #include <> 和 #include "" 都会在实现定义的位置查找文件，并将其包含。区别是若 #include "" 查找成功，则遮蔽 #include <> 所能找到的同名文件；否则再按照 #include <> 的方式查找文件。另外标准库头文件都放在 #include <> 所查找的位置。一般来说 #include <> 的查找位置是标准库头文件所在目录， #include "" 的查找位置是当前源文件所在目录。不过这些都可由编译器调用参数等配置更改。

5、#include的作用是把它后面所写的那个文件的内容，完完整整地、 一字不改地包含到当前的文件中来。值得一提的是，它本身是没有其它任何作用与副功能的，它的作用就是把每一个它出现的地方，替换成它后面所写的那个文件的 内容。简单的文本替换，别无其他。
.h头文件中，只能存在变量或者函数的声明， 而不要放定义。

6、使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。

引用总结
　　（1）在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。

　　（2）用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。

　　（3）引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。

　　（4）使用引用的时机。流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。

7、



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
三个要复习的地方：
1、intentfilter 规则
action、category、data（mimetype、URI（scheme、host、。。。））

2、 touchEvent分发
要总结的几点：
1）、以前都理解错了，onTouchEvent返回true并不代表此事件被拦截了，所以后续事件还是会调用onInterceptTouchEvent方法。而，如果某viewgroup 在此事件调用onInterceptTouchEvent时返回了true，则后续的事件才不会再调用此viewgroup的onInterceptTouchEvent并且后续事件会分配给该viewgroup的onTouchEvent处理。一个事件序列只能被一个viewgroup拦截。
2）、若某view（或者某viewgroup的所有子view都）的onTouchEvent返回了false，那么此view的父容器（或者此viewgroup）的onTouchEvent会被调用。以此类推，直到activity。
3）、若某view的onTouchEvent返回false，那么后续事件都不会再交给它处理了。


3、系统启动流程


4、Binder




学习：
1 ClassLoader

    public static ClassLoader getPkgClassLoader(Context pkgContext) {
        final String dexPath = pkgContext.getApplicationInfo().sourceDir;
        final String libraryPath = null;
        final ClassLoader parentLoader = pkgContext.getClassLoader();
        
        // TODO Create PathClassLoader in a Privileged block ?? --- undetermined
        ClassLoader clsLoader = new PathClassLoader(dexPath, libraryPath, parentLoader); // NOSONAR
        return clsLoader;
    }




---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


根据alps\build\core\main.mk，这应该是android编译系统的主target：
# This is the default target.  It must be the first declared target.
.PHONY: droid
DEFAULT_GOAL := droid
$(DEFAULT_GOAL): droid_targets



Makefile：
1、Makefile的基本规则：

    target ... : prerequisites ...(在同一行，或者用/分隔为多行)
            command(定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头)
            ...
            ...

    target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。

    prerequisites就是，要生成那个target所需要的文件或是目标。

    command也就是make需要执行的命令。（一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。）

这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新或者target不存在的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。

edit : main.o kbd.o command.o display.o /
           insert.o search.o files.o utils.o
            cc -o edit main.o kbd.o command.o display.o /
                       insert.o search.o files.o utils.o

    main.o : main.c defs.h
            cc -c main.c
    kbd.o : kbd.c defs.h command.h
            cc -c kbd.c
    command.o : command.c defs.h command.h
            cc -c command.c
    display.o : display.c defs.h buffer.h
            cc -c display.c
    insert.o : insert.c defs.h buffer.h
            cc -c insert.c
    search.o : search.c defs.h buffer.h
            cc -c search.c
    files.o : files.c defs.h buffer.h command.h
            cc -c files.c
    utils.o : utils.c defs.h
            cc -c utils.c
    clean :
            rm edit main.o kbd.o command.o display.o /
               insert.o search.o files.o utils.o




clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字（make clean）。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。


2、
	include的语法是：

    include <filename>

    filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符），多个文件之间可以用空格隔开。

	你可以在include前加一个减号“-”。如：

    -include <filename>
    其表示，无论include过程中出现什么错误，都不要报错继续执行。
	
3、
make工作时的执行步骤入下：（想来其它的make也是类似）

    1、读入所有的Makefile。
    2、读入被include的其它Makefile。
    3、初始化文件中的变量。
    4、推导隐晦规则，并分析所有规则。
    5、为所有的目标文件创建依赖关系链。
    6、根据依赖关系，决定哪些目标要重新生成。
    7、执行生成命令。

4、objects = *.o

    上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：

    objects := $(wildcard *.o)

这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。


5、
为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。

    .PHONY : clean

只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：

     .PHONY: clean
    clean:
            rm *.o temp

我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。由于伪目标的特性是，总是被执行的，不管它的依赖是否比它新。

6、
make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：

    @echo 正在编译XXX模块......

当make执行时，会输出“正在编译XXX模块......”字串，但不会输出命令，如果没有“@”，那么，make将输出：

    echo 正在编译XXX模块......
    正在编译XXX模块......

如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令，这两条命令应该在同一行。

7、
如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。

有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。

为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：

   clean:
            -rm -f *.o

还有一个全局的办法是，给make加上“-i”或是“--ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。

还有一个要提一下的make的参数的是“-k”或是“--keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。


8、
定义变量
变量会在使用它的地方精确地展开，就像C/C++中的宏一样。替换。
有两种定义方式，第一种部分前后，第二种只能用之前定义的变量。

先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：

    foo = $(bar)
    bar = $(ugh)
    ugh = Huh?

    all:
            echo $(foo)

我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。

这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：

    CFLAGS = $(include_dirs) -O
    include_dirs = -Ifoo -Ibar

当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：

    CFLAGS = $(CFLAGS) -O

    或：

    A = $(B)
    B = $(A)

这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。

为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：

    x := foo
    y := $(x) bar
    x := later

其等价于：

    y := foo bar
    x := later

值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：

    y := $(x) bar
    x := foo

那么，y的值是“bar”，而不是“foo bar”。

9、
（1）、
FOO ?= bar

其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：

    ifeq ($(origin FOO), undefined)
      FOO = bar
    endif
	
（2）、
替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。

还是看一个示例吧：

    foo := a.o b.o c.o
    bar := $(foo:.o=.c)


（3）、
“把变量的值再当成变量”。先看一个例子：

    x = y
    y = z
    a := $($(x))

在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）

比如(subst是个函数):
    x = variable1
    variable2 := Hello
    y = $(subst 1,2,$(x))
    z = y
    a := $($($(z)))

这个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值——“Hello”。（喔，好不容易）


（4）、
我们可以使用“+=”操作符给变量追加值，如：

    objects = main.o foo.o bar.o utils.o
    objects += another.o

于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”

（5）、
如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：

    override <variable> = <value>

    override <variable> := <value>

当然，你还可以追加：

    override <variable> += <more text>
（6）、
使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。


10、
函数的调用（make带的函数并不是很多）：
函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：

    $(<function> <arguments>)

或是

    ${<function> <arguments>}

这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。

函数分类：字符串处理函数、文件名操作函数、

还有
 （1）、foreach函数：

  $(foreach <var>,<list>,<text>)

这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式


 （2）、if函数：
  $(if <condition>,<then-part>)
或是

    $(if <condition>,<then-part>,<else-part>)
可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part>会被计算。

 （3）、call函数：
$(call <expression>,<parm1>,<parm2>,<parm3>...)

<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而表达式<expression>的返回值就做为call函数的返回值。
比如：
    reverse =  $(2) $(1)
    foo = $(call reverse,a,b)

此时的foo的值就是“b a”。


 （4）、
 shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：

    contents := $(shell cat foo)

    files := $(shell echo *.c)

注意，这个函数会新生成一个Shell程序来执行命令
 
 （5）、还有：
 $(warning <text ...>)
 
 $(error <text ...>)
  产生一个致命的错误，<text ...>是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：

    示例一：

    ifdef ERROR_001

    $(error error is $(ERROR_001))

    endif



    示例二：

    ERR = $(error found an error!)

    .PHONY: err

    err: ; $(ERR)


    示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。




11、大致的理解是：

在Makefile中遇到$就会把后面跟的变量名展开。

但如果是$$其实作用是引用shell脚本中定义的变量。这个要在shell定义此变量的同一行使用。。。

而，要在shell脚本中使用Makefile定义的变量（不是指在shell命令后面直接带的参数），应该在同一行中先重新定义这些变量为shell变量在调用shell脚本。因为shell在Makefile中每行都是用单独的进程处理的。

在makefile的规则命令行中使用$var就是在命令中引用makefile的变量，这里仅仅是读取makefile的变量然后扩展开（makefile文件中所有的单$跟变量名都会被扩展），将其值作为参数传给了一个shell命令；而$$var是在访问一个shell命令内定义的变量，而非makefile的变量。如果某规则有n个shell命令行构成，而相互之间没有用';'和'\'连接起来的话，就是相互之间没有关联的shell命令，相互之间也不能变量共享。 









---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Binder:

一、Java 层 与 Native 层的 Binder 及服务调用：
1、

Java层调用ServiceManger.addService后，最终是向Native层的ServiceManager请求增加服务的。
Native层的ServiceManager是只有一个的，而java层的ServiceManager相对于Native的ServiceManager也只是个proxy端，这样，不管是通过Native add service还是通过java add service，整个Android都可以拿到这个service的Binder。
详见：https://blog.csdn.net/fchyang/article/details/82260138

具体添加某service到ServiceManager的逻辑是：
Server创建了Binder实体，为其取一个字符形式可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给SMgr，通知SMgr注册一个名叫张三的Binder，它位于某个Server中。驱动为这个穿过进程边界的Binder创建位于内核中的实体节点以及SMgr对实体的引用，将名字及新建的引用打包传递给SMgr。SMgr收数据包后，从中取出名字和引用填入一张查找表中。

另外注意：
java层的binder实体其实要深入到native层：
Binder.java中的Binder只是对native层BBinder的一个简单封装,真正的实例化还是通过JNI到native层去创建一个JavaBBinderHolder对象，并初始化gBinderOffsets，让其能映射Java层Binder对象，而JavaBBinderHolder中又可以实例化BBinder的实例JavaBBinder，不过BBinder的实例化时机并不在这里，而是在Parcel对象writeStrongBinder的时候



2、java层可以直接通过ServiceManager调用在Native层中注册的Service。

3、Binder中 Server 端的实现是线程池的方式，而不是单线程队列的方式，这样一来，单线程队列的话，Server 的代码是线程安全的，线程池的话，Server 的代码则不是线程安全的，需要开发者自己做好多线程同步。

4、原来打开binder设备的地方是和进程相关的啊，一个进程打开一个就可以了。而binder驱动也会为这个进程维护一个binder_proc数据结构。

5、各结构体理解：
1）、binder_proc是描述进程上下文信息的，每一个用户空间的进程都对应一个binder_proc结构体。Binder驱动的文件节点是"/dev/binder"，每当一个程序打开该文件节点时；Binder驱动中都会新建一个binder_proc对象来保存该进程的上下文信息。
binder_proc中共有4棵红黑树！！！！！！！！！！！！！！！！！！

2）、关于binder_proc结构体中的两个红黑树（它们都是表示同一样东西，只不过是为了内部查找方便而用两个红黑树来表示）：
refs_by_desc;（client端或者ServiceManager进程使用---lyc---）
refs_by_node;（binder驱动使用---lyc---）
当前进程中的binder_ref红黑树节点都不是本进程自己创建的，要么是Service进程将binder_ref插入到ServiceManager中去，要么是ServiceManager进程将binder_ref插入到Client中去。
比如在Client端getService的时候，binder驱动会在Client进程中通过binder_get_ref_for_node为Client创建binder_ref结构体，并分配句柄，同时插入到refs_by_desc红黑树中，可见refs_by_node红黑树，主要是给binder驱动往用户空间写数据使用的。
相对的refs_by_desc主要是为了用户空间往binder驱动写数据使用的，当用户空间已经获得Binder驱动为其创建的binder_ref引用句柄后，就可以通过binder_get_ref从refs_by_desc找到响应binder_ref，进而找到目标binder_node。
user_buffer_offset成员变量是一个ptrdiff_t类型的变量，它表示的是内核使用的虚拟地址与进程使用的虚拟地址之间的差值。

3）、系统服务与bindService等启动的服务的区别：https://juejin.im/post/58c90816a22b9d006413f624#heading-5
主要区别
	（1）、系统服务本身实现binder，它就是个binder。而四大组件之一的Service本身不是binder，通过bindService返回的binder才是。
	（2）、使用方式：使用系统服务一般都是通过ServiceManager的getService得到服务的句柄，这个过程其实就是去ServiceManager中查询注册系统服务。而bindService启动的服务(这种属于四大组件之一，跟系统服务有本质区别)，主要是去ActivityManagerService中去查找相应的Service组件，最终会将Service内部Binder的句柄传给Client。

4）、client端getService之后，便可以获取binder_ref引用（ServiceManager通过驱动在client端对应的binder_proc中创建的），进而获取到Service端的binder_proc与binder_node信息（binder_ref节点中都要这些信息），之后Client便可有目的的将binder_transaction事务插入到binder_proc的待处理列表，并且，如果Service端进程正在睡眠，就唤起进程，其实这里到底是唤起进程还是线程也有讲究，对于Client向Service发送请求的状况，一般都是唤醒binder_proc上睡眠的线程。


6、
IInterface
接口表明了这个类可以通过asBinder()转成一个IBinder，从而在binder驱动中跨进程运输。
例如：在某个client通过binder与某个service通信的时候，可以通过下面的方式把自己的某个binder服务发送个此service，然后此service也就能通过这个binder通知此client了。这里就是通过调用asBinder实现的。（通过asBinder传递出去，接收端通过asInterface再转换成proxy来使用。
注意：Binder驱动过来的IBinder不是Binder，而是BinderProxy，但是为什么我们之前传的参数是一个binder，为什么读出来以后变成了BinderProxy了呢？答案就在这个readStrongBinder里，看jni层的源码可以知道，系统在客户端收到(readStrongBinder)IBinder以后，会保存下来，通过Binder驱动传给Service时，会通过之前保存的Binder在底层创建BinderProxy，然后传给上层）
Parcel data = Parcel.obtain();
data.writeStrongBinder(caller != null ? caller.asBinder() : null);

IBinder
接口表明了类具有跨进程的能力，即可以通过调用transact方法“使用”Binder驱动。
例如：在某个client通过binder与某个service通信的时候，需要调用mRemote.transact()方法来把数据通过Binder驱动传递给Service。 这是通过调用transact()实现的。

6.1、先获取ServiceManager代理Binder对象：
1）、获取的过程分java层和Native层。java层是通过getIServiceManager()，native层是通过defaultServiceManager()。
二者都是进入到Native层的ProcessState类的getContextObject(0)方法去获取的此代理对象，其实就是调用的ProcessState类的getStrongProxyForHandle(0)，实际就是返回一个BpBinder对象。（网上说这个过程不涉及进程间通信。但其实会有一个调用IPCThreadState::transact的过程，去确认ServiceManager是否已经注册到Binder驱动中）
得到这个BpBinder对象后，新建BpServiceManager对象并把BpBinder对象作为属性mRemote。（BpServiceManager就在IServiceManager.cpp中定义，根据继承关系，一层层调用基类构造函数，最终是在BpRefBase的构造函数中设置的MRemote值为此BpBinder）

2）、获取到代理后（实际就是调用BpBinder::transact成员函数。在BpBinder::transact函数中，又会调用IPCThreadState::transact成员函数，这里就是最终与Binder驱动程序交互的地方了。）
	在Android系统的Binder机制中，Server和Client拿到这个Service Manager远程接口之后怎么用呢？
    对Server来说，就是调用IServiceManager::addService这个接口来和Binder驱动程序交互了，即调用BpServiceManager::addService 。而BpServiceManager::addService又会调用通过其基类BpRefBase的成员函数remote获得原先创建的BpBinder实例，接着调用BpBinder::transact成员函数。在BpBinder::transact函数中，又会调用IPCThreadState::transact成员函数，这里就是最终与Binder驱动程序交互的地方了。回忆一下前面的类图，IPCThreadState有一个PorcessState类型的成中变量mProcess，而mProcess有一个成员变量mDriverFD，它是设备文件/dev/binder的打开文件描述符，因此，IPCThreadState就相当于间接在拥有了设备文件/dev/binder的打开文件描述符，于是，便可以与Binder驱动程序交互了。
    对Client来说，就是调用IServiceManager::getService这个接口来和Binder驱动程序交互了。具体过程上述Server使用ServiceManager的方法是一样的，这里就不再累述了。

3）、注意：
杂：
binder_transaction_data这个数据结构就是在IPCThreadState::writeTransactionData中形成的。最终是把cmd 和 binder_transaction_data一起写入到mOut中。
然后会调用：IPCThreadState::waitForResponse()。
client端和Server端最后都是通过talkwithdriver()里面的ioctl()方法最终进入到驱动程序中运行的。对应了Binder驱动程序的binder_ioctl函数。

7、对于addService,即添加系统服务。
会进行权限检查（在service_manager.c中）：
int svc_can_register(unsigned uid, uint16_t *name)
 {
    unsigned n;
    // 谁有权限add_service 0进程（即root用户），或者 AID_SYSTEM进程（即system 进程，1000）
    if ((uid == 0) || (uid == AID_SYSTEM))
        return 1;
     for (n = 0; n < sizeof(allowed) / sizeof(allowed[0]); n++)
        if ((uid == allowed[n].uid) && str16eq(name, allowed[n].name))
            return 1;
    return 0;
}
所以，只有root 、system进程或者特殊配置的进程 才能addService成为系统服务到ServiceManager，其它app中的服务都是继承Service组件，通过AMS进行管理的。

8、对于bindService：
Service的bind需要一个ServiceConnection对象，这个对象其实是为了AMS端在启动Service后回调用的。
Activity的bindService流程：
1）、Client的Activity调用bindService：通过Binder通知ActivityManagerService，要启动哪个Service
2）、ActivityManagerService创建ServiceRecord，并利用ApplicationThreadProxy回调，通知目标APP新建并启动对应的Service。
3）、ActivityManagerService把Service启动起来后，继续通过ApplicationThreadProxy，通知APP进行bindService（即，会执行服务端的Service中的onBind()方法），其实就是让Service返回一个Binder对象给ActivityManagerService，以便AMS传递给Client
4）、ActivityManagerService把从Service处得到这个Binder对象传给Client的Activity，这里是通过IServiceConnection这个binder实现。
5）、Activity被唤醒后通过Binder Stub的asInterface函数将Binder转换为代理Proxy（即onConnected中的操作），完成业务代理的转换，之后就能利用Proxy进行通信了。

9、binder的内存限制：即通过mmap函数映射的内存大小。
1）、binder驱动要求映射的内存大小不能超过4M
2）、ServiceManager默认需要映射的内存大小为128K
3）、一般应用程序可映射的内存大小为1M，也就是说通过binder传输的数据大小不能超过1M，也就是说通过contentprovider或者intent传递的数据大小不能超过1M。

10、ServiceManager的特殊之处：
1）、对于ServiceManager这个Server来说，Client如果想要获得ServiceManager远程接口，不必通过进程间通信机制来获得，因为ServiceManager远程接口是一个特殊的Binder引用，它的引用句柄一定是0。		获取ServiceManager远程接口的函数是defaultServiceManager，这个函数声明在frameworks/base/include/binder/IServiceManager.h文件中。

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$# ----传递给程序的总的参数数目 　
$? ----上一个代码或者shell程序在shell中退出的情况，如果正常退出则返回0，反之为非0值。 　　
$* ----传递给程序的所有参数组成的字符串。 　　
$n ----表示第几个参数，$1 表示第一个参数，$2 表示第二个参数 ... 　　$0 ----当前程序的名称
$@----以"参数1" "参数2" ... 形式保存所有参数 　　
$$ ----本程序的(进程ID号)PID 　　
$! ----上一个命令的PID
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TMUX
常用命令

tmux new　　创建默认名称的会话（在tmux命令模式使用new命令可实现同样的功能，其他命令同理，后文不再列出tmux终端命令）

tmux new -s mysession　　创建名为mysession的会话

tmux ls　　显示会话列表

tmux a　　连接上一个会话

tmux a -t mysession　　连接指定会话

tmux rename -t s1 s2　　重命名会话s1为s2

tmux kill-session　　关闭上次打开的会话

tmux kill-session -t s1　　关闭会话s1

tmux kill-session -a -t s1　　关闭除s1外的所有会话

tmux kill-server　　关闭所有会话

常用快捷键

prefix s　　列出会话，可进行切换

prefix $　　重命名会话

prefix d　　分离当前会话

prefix D　　分离指定会话

　　

窗口管理
prefix c　　创建一个新窗口

prefix ,　　重命名当前窗口

prefix w　　列出所有窗口，可进行切换

prefix n　　进入下一个窗口

prefix p　　进入上一个窗口

prefix l　　进入之前操作的窗口

prefix 0~9　　选择编号0~9对应的窗口

prefix .　　修改当前窗口索引编号

prefix '　　切换至指定编号（可大于9）的窗口

prefix f　　根据显示的内容搜索窗格

prefix &　　关闭当前窗口

　

窗格管理
prefix %　　水平方向创建窗格

prefix "　　垂直方向创建窗格

prefix Up|Down|Left|Right　　根据箭头方向切换窗格

prefix q　　显示窗格编号

prefix o　　顺时针切换窗格

prefix }　　与下一个窗格交换位置

prefix {　　与上一个窗格交换位置

prefix x　　关闭当前窗格

prefix space(空格键)　　重新排列当前窗口下的所有窗格

prefix !　　将当前窗格置于新窗口

prefix Ctrl+o　　逆时针旋转当前窗口的窗格

prefix t　　在当前窗格显示时间

prefix z　　放大当前窗格(再次按下将还原)

prefix i　　显示当前窗格信息

 

　　

其他命令
tmux list-key　　列出所有绑定的键，等同于prefix ?

tmux list-command　　列出所有命令

　　

以上为tmux的常见操作，基本可以满足大部分的工作需求，至于更高端的操作待日后再整理。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------